//D飞机降落
//题目描述
//N 架飞机准备降落到某个只有一条跑道的机场。其中第 i 架飞机在 Ti 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 Di 个单位时间，即它最早
//可以于 Ti 时刻开始降落，最晚可以于 Ti + Di 时刻开始降落。降落过程需要 Li个单位时间。
//一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。
//请你判断 N 架飞机是否可以全部安全降落。
//输入格式
//输入包含多组数据。
//第一行包含一个整数 T，代表测试数据的组数。
//对于每组数据，第一行包含一个整数 N。
//以下 N 行，每行包含三个整数：Ti，Di 和 Li。
//输出格式
//对于每组数据，输出 YES 或者 NO，代表是否可以全部安全降落。
//样例输入
//2
//3
//0 100 10
//10 10 10
//0 2 20
//3
//0 10 20
//10 10 20
//20 10 20
//样例输出
//YES
//NO
//提示
//对于第一组数据，可以安排第 3 架飞机于 0 时刻开始降落，20 时刻完成降落。安排第 2 架飞机于 20 时刻开始降落，30 时刻完成降落。安排第 1 架飞机于 30 时刻开始降落，40 时刻完成降落。
//对于第二组数据，无论如何安排，都会有飞机不能及时降落。
//
//
//对于 30% 的数据，N ≤ 2。
//对于 100% 的数据，1 ≤ T ≤ 10，1 ≤ N ≤ 10，0 ≤ Ti , Di , Li ≤ 10^5。

//n限制小，选择暴力枚举，找到降落顺序，详细注释
#include <stdio.h>
const int N = 10+20;
struct plane{
	int t, d, l;
}p[N]; // 飞机
int n;
bool sc[N]; // 记录飞机是否成功降落
int max(int a, int b) {
	if(a > b) {
		return a;
	}else {
		return b;
	}
}
bool dfs(int u, int time) { // u表示安排到第几架飞机， time表示上一架飞机降落的时间
	if(u >= n) {
		return true; // 所有飞机都降落成功
	}
	for(int i = 0; i < n; ++ i) {
		if(!sc[i]) { // 找到还没有降落的飞机看是否满足降落条件
			sc[i] = true; // 先标记成功降落
			if(p[i].t + p[i].d < time) { // 当飞机到达时间与盘旋时间和小于上一架飞机降落时间
				//说明这架飞机不能成功降落，回溯降落状态， 
				sc[i] = false;
				//并且这架飞机在此序列无法成功降落那么后续也无法成功(time会增大，if条件也不会满足) 
				return false;
			}
			//得到这架飞机降落的时间
			// max(time,p[i].t)：飞机开始降落前花费的时间
			//值为time时：飞机到达但上一架飞机还未落地，只能等到上一飞机落地后开始降落
			//值 p[i].t： 飞机到达且上一架飞机已经落地，到达后就降落 
			int t = max(time, p[i].t) + p[i].l;
			//确定该架飞机此时降落 ，继续寻找下一个降落的飞机 
			if(dfs(u+1, t)) {
				return true; // 该降落顺序飞机全部能降落 
			}
			//后续有飞机不满足降落条件，回溯前面的降落顺序，重新寻找 
			sc[i] = false;
		}
	}
	return false;
}
void solve(){
	scanf("%d", &n);
	for(int i = 0; i < n; ++ i){ // 初始化飞机状态 
		scanf("%d%d%d", &p[i].t, &p[i].d, &p[i].l);
		sc[i] = false;
	}
	if(dfs(0, 0)) {
		printf("YES");
	}
	else {
		printf("NO");
	}
}
int main()
{
	int t;
	scanf("%d", &t);
	while(t --){
		solve();
	}
	return 0;
}
