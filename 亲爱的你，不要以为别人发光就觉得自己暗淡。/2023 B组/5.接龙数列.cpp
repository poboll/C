//D接龙数列
//对于一个长度为 K 的整数数列：A1, A2, . . . , AK，我们称之为接龙数列当且仅当 Ai 的首位数字恰好等于 Ai−1 的末位数字 (2 ≤ i ≤ K)。
//例如 12, 23, 35, 56, 61, 11 是接龙数列；12, 23, 34, 56 不是接龙数列，因为 56的首位数字不等于 34 的末位数字。所有长度为 1 的整数数列都是接龙数列。
//现在给定一个长度为 N 的数列 A1, A2, . . . , AN，请你计算最少从中删除多少个数，可以使剩下的序列是接龙序列？
//输入格式
//第一行包含一个整数 N。
//第二行包含 N 个整数 A1, A2, . . . , AN。
//输出格式
//一个整数代表答案。
//样例输入
//5
//11 121 22 12 2023
//样例输出
//1
//提示
//删除 22，剩余 11, 121, 12, 2023 是接龙数列。
//对于 20% 的数据，1 ≤ N ≤ 20。
//对于 50% 的数据，1 ≤ N ≤ 10000。
//对于 100% 的数据，1 ≤ N ≤ 105，1 ≤ Ai ≤ 10^9。所有 Ai 保证不包含前导 0。

// 暴力
//#include <stdio.h>
//const int N = 1e5 + 10;
//int arr[N] = {0}; // 先定义全局变量数组
//int n, res = 0, ans = 0; // res记录每一轮的最长长度，ans记录总共最长长度
//int get_first(int x) { // 获取后一位的第一位数
//	while(x > 10) {
//		x /= 10;
//	}
//	return x;
//}
//int get_last(int x) { // 获取前一位的最后一位数
//	return x % 10;
//}
//void dfs(int x, int y) { // x表示当前考虑到第几个数，y表述需要考虑的上一个数的位置，y = 0表示当前考虑的是第一个数
//	if(x > n) { // 如果已经考虑完了开始进行返回
//		return;
//	}
//	if(y == 0) { // 如果当前考虑的是第一个数
//		res ++; // 将第一位记录进去
//		dfs(x + 1, x); // 将前一位更新，再进行下一层
//	}
//	else if(get_last(arr[y] != get_first(arr[x]))){ // 如果当前的首位不等于前一位的末尾
//		dfs(x + 1, y); // 保持前一不变，略过当前一层继续递归到下一层
//	}
//	else { // 如果满足当前条件
//		res ++;
//		dfs(x + 1, x); // 更新y并且递归到下一层
//	}
//}
//int max(int a, int b) { // 听说手写max会更快？
//	return a > b ? a : b;	
//}
//int main(void) {
//	scanf("%d", &n);
//	for(int i = 1; i <= n; ++ i) {
//		scanf("%d", &arr[i]);
//	}
//	for(int i = 1; i <= n; ++ i) {
//		res = 0; // 更新res
//		dfs(i, 0); // 从第i个数开始考虑，寻找最长的序列
//		ans = max(ans, res); // 更新ans
//		if(ans >= n - i) { // 如果当前的方案(ans)已经大于剩下的数字数量，就剪枝省去后面的搜索
//			break;
//		}
//	}
//	printf("%d\n", n - ans); // 答案：总数目-当前最长方案数
//	return 0;
//}

// 状态转移
//集合表示f(i,j)枚举到前i个数,以j为结尾,序列中最大加入多少个数
//状态转移,f(i,j)每次先继承上一轮结果,只有第i个数首位等于f(i,j)的j时才能更新,所以只要相等就比较选出最大值即可
/*
5
11 121 22 12 2023
*/
#include <stdio.h>
const int N = 1e5 + 10;
int n, m, ans;
int f[N][10], a[N];
int fun(int x) {
	while(x / 10){
		x /= 10;
	}
	return x;
}
int max(int a, int b) { // 听说手写max会更快？
	return a > b ? a : b;	
}
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i) {
		scanf("%d", &a[i]);
	}
	
	for(int i = 1;i <= n; ++ i) {
		for(int j = 0; j <= 9; ++ j) {
			f[i][j] = f[i - 1][j]; // 先继承
		}
		f[i][a[i]%10] = max(f[i][a[i]%10], f[i-1][fun(a[i])]+1); // 要么是继承的结果大,要么是把他加入新的序列结果大 
	}
	
	ans = -1;
	for(int i = 0; i <= 9; ++ i) {
		ans = max(f[n][i], ans);
	}
	printf("%d", n - ans);
	return 0;
}
