# AcWing 算法基础课学习记录（C/C++，备战蓝桥杯）Day1 - Day30

备战蓝桥杯学习路线：acwing算法基础课->acwing蓝桥杯课->算法竞赛进阶指南

从今天开始系统性的学习算法，由于基础课和蓝桥课一共有85小时，现在每天平均是30mins到45mins，可能不是很够。从明天开始，每天看视频讲解一小时并且要消化内容，估计一起得花3-4小时。这样子差不多二月底，三月初可以结束视频课程）

**Day1**.(2023.2.8)

学习思路：1 先理解算法主要思想，2 背模板，3多做几道题（在做题的时候，当你AC了，马上把代码删除，再重新写一边，重复两三次）

## 基础算法

### 排序

#### 快速排序（nlogn） 分治

1. 判断退出条件

2. 确定分界点，一般选择左端点q[l]，右端点q[r]或者中间q[(l+r)/2]

3. 调整范围，将左边调整为小于等于分界点，右边调整为大于等于分界点

   ![快排](https://s2.loli.net/2023/02/10/qLHKPWzOMVxUpTb.png)

   对于第二步的调整区间，具体就是弄两个指针，分别指向数组的左右边界；不断的向中间遍历，将遍历过程中左边比x大的数和右边比x小的数交换，直到 i，j 相遇。

4. 递归处理左右两个区间，直到细分到不能细分

   其中重难点是2，简单方法（但耗空间）是：

   1. 先设置两个数组a[], b[]

   2. 数组q[l~r]中小于等于de的放入a[]，大于等于de的放入b[]

   3. 然后将a和b合并放入数组q，a在左边，b在右边

主要方法是，在数组两端分别设置指针i,j，**while q[i]<de: i++，while q[j]>de: j--，if i<j swap(q[i],q[j]) else 递归处理左边部分(l,j)和右边部分(j+1,r)**。重复上述步骤。

（边界问题，mid和递归的划分要对应，取不到出错）

##### 快排模板：

```C++
/*快排模板（以j为分界）
快排属于分治算法，分治算法都有三步：1、分成子问题 2、递归处理子问题 3、子问题合并
快速排序的算法思想
（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
（2）治理：对两个子序列进行快速排序
（3）合并：将排序好的两个子序列合并在一起，得到原问题的解
分解是一个需要考虑的问题，如果基准元素选取不当，会造成两个子序列的规模分别为0和n-1，这样快速排序就退化成冒泡排序了。最理想的状态是把序列分解成两个规模相当的子序列。
对基准元素的选取一般有以下几种方法
1、取第一个元素 2、取最后一个元素 3、取中间位置的元素 4、取第一个元素、最后一个元素、中间位置的元素三者的中位数 5、取第一个元素和最后一个元素之间位置的随机数k（low≤k≤high),选R[k]作为基准元素。*/
//快排代码模板（acwing）
void quick_sort(int q[], int l, int r){
    //递归的终止情况
    if (l >= r) return;//if (l == r) return;
    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//等同于x = q[(l + r + 1) / 2] 注意边界问题：左i不能取左l，右j不能取右r
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //第二步：递归处理子问题
    quick_sort(q, l, j);//quick_sort(q, l, i-1)
    quick_sort(q, j + 1, r);//quick_sort(q, i, r)
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
void quick_sort(int a[], int l, int r) {
    if (l >= r) return ;

    int x = a[l + r >> 1], i = l, j = r;

    while (i <= j) {
        while(a[i] < x) i++;
        while(a[j] > x) j--;
        if (i <= j) swap(a[i++], a[j--]);
    }
    quick_sort(a, l, j);
    quick_sort(a, i, r);
}
```

##### ACWING:785

```C++
/*785.快速排序
给定你一个长度为 n 的整数数列。
请你使用快速排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 n。
第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。
输出格式
输出共一行，包含 n 个整数，表示排好序的数列。
数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5*/
#include <iostream>
using namespace std;
const int N = 1000010;
int q[N];
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) {
      scanf("%d", &q[i]);
    }
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i ++ ) {
      printf("%d ", q[i]);
    }
    return 0;
}
```

##### ACWING:786

```C++
/*786. 第k个数
给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列的第k小的数是多少。
输入格式
第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在1~109109范围内），表示整数数列。
输出格式
输出一个整数，表示数列的第k小数。
数据范围
1≤n≤1000001≤n≤100000,
1≤k≤n1≤k≤n
输入样例：
5 3
2 4 1 5 3
输出样例：
3
*/
/*
1.找到分界点x，q[l]，q[(L + R)]，q[R]
2.左边所有数Left <= x，右边所有数Right >= x
3.递归排序Left，递归排序Right
	1、k <= Sl，递归Left
	2、k > Sl，递归Right，是第k-Sl个数
快选只用递归一边*/
/*使用快排模板
#include<iostream>
using namespace std;
 
const int N = 100010;
int n, k;
int q[N];
 
void quick_sort(int q[], int l, int r){
  if(l>=r) return;
  int x = q[(l+r)/2], i = l-1, j = r+1;
  while(i<j){
      do i++; while(q[i]<x);
      do j--; while(q[j]>x);
      if (i<j) swap(q[i],q[j]);
  }
  quick_sort(q,l,j);
  quick_sort(q,j+1,r); 
}
int main() {
  scanf("%d %d",&n,&k);
  for(int i=0;i<n;i++) {
    scanf("%d",&q[i]);
  }
  quick_sort(q,0,n-1);
  for(int i=0;i<n;i++)
	{   
		if (i==k-1) {
      printf("%d",q[i]);
    }
	}
	return 0;
}*/
/*1、找到分界点x，q[L],q[(L+R)/2],q[R]
2、左边所有数Left<=x，右边所有数Right>=x
3、递归排序Left，递归排序Right
  1、k<=Sl，递归Left
  2、k>Sl，递归Right，k-Sl
时间复杂度：n+n/2+n/4+...=N(1+1/2+1/4+...)<=2n*/
#include <iostream>
using namespace std;
const int N = 100010;
int n,k;
int q[N];
int quick_sort(int l, int r,int k){//C++全局变量和局部变量重名优先使用局部变量
    if(l >= r) {//区间内
        return q[(l + r)/2];
    }
    int x = q[(l + r)/2], i = l-1, j = r+1;
    while (i < j) {
        while(q[ ++ i] < x);
        while(q[ -- j] > x);
        if(i < j) {
          swap(q[i], q[j]);
        }
    }
    int s1 = j - l + 1;
    if (k <= s1) {
        return quick_sort(l, j, k);
    }
    else {
        return quick_sort(j + 1, r, k - s1);//return quick_sort(q,j+1,r,k-(j-l+1));
    }
}
int main(){
  int n,k;
  scanf("%d %d", &n, &k);
  for(int i = 0; i < n; i ++) {
      scanf("%d",&q[i]);
  }
  printf("%d",quick_sort(0, n - 1, k));
  return 0;
}
```



**Day2**.(2023.2.9)

#### 归并排序（nlogn） 分治

归并排序的主要思想也是分治，它和快排的思想不同，快排是边分边治，它是先分后治。

1. 判断退出条件

2. 确定分界点 mid=(r+l)/2

3. 递归排序左右两部分 （根据选出的分界点，将分界点左边的递归处理，右边的递归处理）

4. 归并-合二为一 （递归的终止条件是l>=r，返回后就要考虑怎么把左右两部分正确的合在一起）放到temp中

5. 存回原数组中


##### 归并模板：

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

##### ACWING:787

```cpp
/*787.归并排序
给定你一个长度为l的整数数列。
请你使用归并排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 l。
第二行包含 l 个整数（所有整数均在1~10^9范围内），表示整个数列。
输出格式
输出共一行，包含l个整数，表示排好序的数列。
数据范围
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5
*/
/*算法实现
全分解，再排序合并
四步：
    取中位数，分解
    获取两区间起始点，对比合并于一个数组中
    扫尾
    将顺序数组按原数组起始存储至原数组中
*/
#include <iostream>
using namespace std;
// 设置可排序数量范围
const int N = 100010;
int n;
// 存放有序序列的临时数组
int q[N],tmp[N];
void merge_sort(int q[], int l, int r) {
    //边界的终止情况
    if (l >= r) {
        return;
    }
    //第一步：分成子问题
    int mid = l + r >> 1;
    //第二步：递归处理子问题
    merge_sort(q, l ,mid),merge_sort(q, mid+1, r);
    //第三步：合并子问题。设置k为存放有序序列的数组下标；i为待比较序列中第一个子序列的起始下标，j为待比较序列中第二个子序列的起始下标。
    int k = 0, i = l, j = mid + 1;
    while (i < mid && j <= r) {
        if(q[i] <= q[j]) {
            tmp[k ++ ] = q[i ++ ];
        } else {
            tmp[k ++ ] = q[j ++ ];
        }
  }
  // 比较完后，若第一个子序列还有剩余，将剩余的值添加到tmp中；第二个子序列剩余同理。
    while (i <= mid) {
        tmp[k ++ ] = q[i ++ ];
    }
    while (j <= r) {
        tmp[k ++ ] = q[j ++ ];
    }
    // 将有序序列存放至原数组中，相当于完成一轮合并
    for (k = 0, i = l; i <= r; k++, i ++) {
        q[i] = tmp [k];
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i ++){
        scanf("%d", &q[i]);
    }
    merge_sort(q, 0, n-1);
    for (int i = 0; i < n; i ++) {
        printf("%d ",q[i]);
    }
    return 0;
}
```

##### ACWING:788

逆序对是用归并的思想（分治）做的，只求逆序对中大的在左边序列，小的在右边序列的情况（最开始划分区间划分到为1的时候会解决大的和小的在一边的情况）。然后怎样计算有多少个逆序对呢：mid-i+1，当a[i]都比a[j]大的时候，左边序列i后面的值肯定也都比a[j]大。

```cpp
/*788.逆序对的数量
给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。
逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。
输入格式
第一行包含整数 n，表示数列的长度。
第二行包含 n 个整数，表示整个数列。
输出格式
输出一个整数，表示逆序对的个数
数据范围
1≤n≤100000
数列中的元素的取值范围 [1,]。
输入样例
6
2 3 4 5 6 1
输入样例
5*/
/*解题思路：
假设一个函数merge_sort已经能求出逆序对的数量，若将这组数平分为左右两个部分，则逆序对的数量=左侧数内部逆序对的数量+右侧数内部逆序对的数量+右侧每个数与左侧数组成的逆序对数量的和。
1.把数组分成某个位置分成两个数组[L, R] => [L, mid],[mid + 1, R]
2.对两边递归排序并计算出在同一边逆序对的数量 递归排序[L, mid]和[mid + 1, R]
3.归并数组，并计算不在同一边的逆序对的数量 归并，将左右梁国有序序列合并成一个有序序列
4.然后遍历看看有没有没归并的数
5.然后赋值给原数组
	1.左半边内部的逆序对数量：merge_sort(L, mid)
	2.右半边内部的逆序对数量：merge_sort(mid + 1, R)
	3.归并，将左右两个有序序列合并成一个有序序列
*/
#include<iostream>
using namespace std;
const int N = 100010;
int n;
int q[N],tem[N];
long long merge_sort(int q[],int l,int r){// int 在1e5 时会爆
    if(l >= r) return 0;
    int mid = (l + r) >> 1;
    //递归左右两边逆序数对
    long long res = merge_sort(q,l,mid) + merge_sort(q,mid + 1,r);
    
    //归并并计算不在一边的逆序数对
    int k = 0,i = l,j = mid + 1;
    while(i <= mid && j <= r)
        if(q[i] <= q[j]) tem[k++] = q[i++];
        else {
            tem[k++] = q[j++];
            res += mid - i + 1;//计算逆序对数    
            //j的初始值为mid+1，此时当前的q[j]只与(q[k]，i<=k<j)这几个元素存在逆序关系；
            //归并排序从mid 的中间往两侧归并，因此中间元素是相对于当前mid有序的；    
        }
    //扫尾
    while (i <= mid) tem[k++] = q[i++];
    while (j <= r) tem[k++] = q[j++];
    
    //赋给原数组
    for (int i = l,j = 0; i <= r; i ++ ,j++)
        q[i] = tem[j];
        
        return res;
}
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    printf("%ld",merge_sort(q,0,n - 1));
    
    return 0;
}
```

#### C++的sort()

快速排序+插入排序



**Day3**.(2023.2.10)

Day2的List五种生成方式和数据结构分析是今天做的。本来说把归并的788题做了，结果进去就跳转到算法基础课的活动，然后在leetcode上也没找到合适的题就把归并和快排复习了下，发现归并都是用<=或>=，而快排只有最开始判断的时候用了>=，其余都没有>=或<=，如果有的话还会报错。

### 二分

这一节在刚开始听的时候还有点蒙蔽，一上来就在讲方法和思想，我连算法要解决的问题都还不清楚 。然后二分的本质不是单调性，而是边界。比如：给定一个区间，在这个区间中定义了某种性质，使得这个性质在有左半边区间是满足的，而右半部不满足（注意两者没有交点，当整数二分时），则二分就可以寻找到这个边界左半边的边界和右半的都可以找到。而找到左边的边界，和右边的边界就分别是用两个不同的模板了。

![二分](https://s2.loli.net/2023/02/10/piJbPwmfCTN6QVO.png)

这里解决的算法问题是假定先找黑色那个点，后找绿色那个点，然后整体思路就是：

找黑色的边界点，首先检查中间值是否满足黑色性质，

如果满足，则在mid右边部分找[mid,r], l=mid，注意是包含mid。否则mid左边找[l,mid-1],r=mid-1

找绿色的边界点，首先检查中间值是否满足绿色性质，

如果满足，则在mid的左边部分找[l,mid],r=mid。否则mid右边找[mid+1,r],l=mid+1

整数二分：

注意：在找右边边界时需要mid=(l+r+1)/2 （如果不加1，假设l=r-1，如果此时True会无限递归），左边是mid=(l+r)/2。

**模板**：解决单调数组找一个数最初和最后出现的位置，未出现则返回-1 -1

说实话，二分算法的过程我感觉很抽象，必须要依靠画图才能肯定。

当你找左边界，是找所有>=num的数，如果arr[mid]>=num，那么答案一定在左半边，那么r=mid，因为也有可能就是mid。

![浮点二分](https://s2.loli.net/2023/02/10/iVycQvhpebPW9RD.png)

假如红色点是左边界，现在mid在黄色点，是>=num（红色点的值）的，则应该去左边找，则令右边界为mid。

#### 整数二分

二分保证一定有解，题目不一定有解

1. 写while
2. 取mid = (l + r) / 2
3. 写check函数
4. 看check函数决定l = mid还是r = mid(l=mid时候第一步+1)

##### 整数二分模板（两种）：

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

##### ACWING:789

```cpp
/*789. 数的范围
给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。
对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。
如果数组中不存在该元素，则返回 -1 -1。
输入格式
第一行包含整数 n 和 q，表示数组长度和询问个数。
第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。
接下来 q 行，每行包含一个整数 k，表示一个询问元素。
输出格式
共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回 -1 -1。
数据范围
1≤n≤100000
1≤q≤10000
1≤k≤10000
输入样例：
6 3
1 2 2 3 3 4
3
4
5
输出样例：
3 4
5 5
-1 -1
*/
/*二分法，但是不是找其中的值，而是找到这个元素的边界。因为时升序数组，故我们找left时找第一个大于等于x的数的index，right时找最后一个小于等于x的数的index
上述都是从左向右看*/
#include <iostream>
using namespace std;
const int N = 100010;
int n, m;
int q[N];
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    while (m -- )
    {
        int x;
        scanf("%d", &x);
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if (q[l] != x) cout << "-1 -1" << endl;//l是边界，如果和x不等就是没有这个值
        else
        {
            cout << l << ' ';
            int l = 0, r = n - 1;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (q[mid] <= x) l = mid;
                else r = mid - 1;
            }
            cout << l << endl;
        }
    }
    return 0;
}
```

##### ACWING:790

```cpp
/*790.数的三次方根
给定一个浮点数 n，求它的三次方根。
输入格式
共一行，包含一个浮点数 n。
输出格式
共一行，包含一个浮点数，表示问题的解。
注意，结果保留 6 位小数。
数据范围
−10000≤n≤10000
输入样例：
1000.00
输出样例：
10.000000
*/
/*思路
浮点数的二分，在0~n间一直二分直到精度<1e-9停止*/
#include <iostream>
using namespace std;
int main() {
    double a;
    cin >> a;
    if(a < 0) {
        cout << '-';
        a = a * (-1);
    }
    double l = 0, r = a;
    while(r - l > 1e-8) { //绝对值是否大于一个很小的数值0.00000001
        double mid = (l + r) / 2;
        if(mid * mid * mid >= a) r = mid;
        else l = mid;
    }
    printf("%lf", l);
    return 0;
}
```



#### 浮点数二分：

> eg: 找平方根

浮点数二分相对于整数二分就简单许多，不需要有加一减一等操作，只需要判断要找的数在mid左边还是右边。

浮点数二分区间长度足够小：看成一个数（**注意精度问题：**防止误差出现-->增加精度）

- 保留四位小数 精度 < 1e-6
- 五位小数 1e-7
- 六位小数 1e-8

```cpp
/*浮点数二分*/
#include<iostream>
using namespace std;
int main() {
    double x;
    cin >> x;
    double l = 0, r = x;
    //不用精度表示（精度足够小就停止）
    //for (int i = 0; i < 100; i ++)开一百次方-->极小
    while (r - l >1e-8) {//保留四位小数-1e-6 永远多2 一直做
        double  mid = (l + r) / 2;//每次求中点
        if (mid * mid >= x) r = mid;
        else l = mid;
    }
    printf("%lf\n",l);
    return 0;
}
```



**Day4**.(2023.2.11)

##### ACWING:790

```cpp
```

### 高精度

- 大整数存储：用字符串读，用vector存（小端）

Java和Python不需要关注高精度，Java有大整数类，Python本身就是无限大。但万一以后搞C++去了呢？

大数运算一般有A+B, A-B, A*a, A/a。其中大写代表大数（位数在1000000之内），小写代表小数（值效于10000）。解决这几个问题一般是模拟人工加法的过程：

当然首先要看的是怎么存储两个大数，要用数组来存储，而且是数组的低位存大数的低位，假如123456789为大数，则arr[0]=9, arr[1]=8 ... arr[8]=1。这是因为高位可能要进位，这样进位后不需要移动数组。

#### 高精度加法 A+B 10^6

1. 算每一位的和放到vector中
2. 当前位 %10，进位 /10
3. 最后要处理是否还有进位

##### 高精度加法模板：

```cpp
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

##### ACWING:791

```cpp
/*791.高精度加法
给定两个正整数（不含前导0），计算它们的和。
输入格式
共两行，每行包含一个整数。
输出格式
共一行，包含所求的和。
数据范围
1≤整数长度≤100000
输入样例：
12
23
输出样例：
35
*/
/*vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果你用.at()访问的话，也可以做越界检查。
v.push_back(t)  //在数组的最后添加一个值为t的数据
v.size()   //当前使用数据的大小
v.pop_back();  // 弹出容器中最后一个元素（容器必须非空）
v.back();   // 返回容器中最后一个元素的引用
*/
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e6 +10;
// C = A + B
vector<int> add(vector<int> &A, vector<int> &B) {//C++11新特性  添加引用-->提高效率
    vector<int> C;//定义数组C存两数之和
    int t = 0;//上一位的进位
    for (int i = 0; i < A.size() || B.size(); i ++) {
        if (i < A.size()) t += A[i];//按位做加法
        if (i < B.size()) t += B[i];//B的高位全加进去
        C.push_back(t % 10);//t存储该位a，b和模10即为结果
        t /= 10;//t存储进位为0或1
    }
    if (t) C.push_back(1);//最高位进位1
    return C;
}
int main() {
    string a, b;//定义字符串a，b
    vector<int> A, B;//定义数组A,B
    cin >> a >> b; //输入两个数a，b    a = "123456"
    for (int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0');// A = [6, 5, 4, 3, 2, 1]  把字符串中字符变为整型数字并逆序存入数组
    for (int i = b.size() - 1; i >= 0; i --) B.push_back(b[i] - '0');
    auto C = add(A , B);//调用函数，返回和存入数组C。auto编译器自己推断类型等价于 vector<int> C
    for (int i = C.size() - 1; i >= 0; i --) printf("%d", C[i]);//遍历输出C中元素即为两数和
    return 0;
}
```

#### vector

vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果用.at()访问的话，也可以做越界检查。

```cpp
v.push_back(t)  //在数组的最后添加一个值为t的数据
v.size()   //当前使用数据的大小
v.pop_back();  // 弹出容器中最后一个元素（容器必须非空）
v.back();   // 返回容器中最后一个元素的引用
```

#### 高精度减法 A-B 10^6 （）

1. 先比较位数，然后从最高位开始比较。A>=B，否则算-(B-A)
2. 循环处理每一位（判断B的位数是否还能减），记录是否有借位
3. 处理前导0

##### 高精度减法模板：

```cpp
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

##### ACWING:792

```cpp
/*792.高精度减法
给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。
输入格式
共两行，每行包含一个整数。
输出格式
共一行，包含所求的差。
数据范围
1≤整数长度≤10^5
输入样例：
32
11
输出样例：
21
*/
/*vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果用.at()访问的话，也可以做越界检查。
v.push_back(t)  //在数组的最后添加一个值为t的数据
v.size()   //当前使用数据的大小
v.pop_back();  // 弹出容器中最后一个元素（容器必须非空）
v.back();   // 返回容器中最后一个元素的引用
*/
#include <iostream>
#include <vector>
using namespace std;
//判断是否有 A >=B
bool cmp(vector<int> &A, vector<int> &B) {//判断A,B大小关系
    if (A.size() != B.size()) return A.size() > B.size();//直接ruturn 了就不用else
    for (int i = A.size() - 1; i >= 0; i --) {
        if(A[i] != B[i]) {
            return A[i] > B[i];//逐位看A和B哪个数较大
        }
    }
    return true;//所有都相等返回true
}
// C = A + B
vector<int> sub(vector<int> &A, vector<int> &B) {//C++11新特性  添加引用-->提高效率
    vector<int> C;
    for(int i = 0, t = 0; i < A.size(); i ++ ) {
        t = A[i] - t;//t表示进位
        if (i < B.size()) t -= B[i];//判断B是否还存在
        C.push_back((t + 10) % 10);
        // 若t>=0,则返回t，若小于0则表示借位需+10，合并即为(t + 10) % 10 )
        if (t < 0) t = 1;
        else t = 0;
    }
    while (C.size() > 1 && C.back() == 0) {
        C.pop_back();//去掉前导0，如果c=0则不能去掉该0；
    }
    return C;
}
int main() {
    string a, b;//定义字符串a，b
    vector<int> A, B;//定义数组A,B
    cin >> a >> b; //输入两个数a，b    a = "123456"
    for (int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0');// A = [6, 5, 4, 3, 2, 1]  把字符串中字符变为整型数字并逆序存入数组
    for (int i = b.size() - 1; i >= 0; i --) B.push_back(b[i] - '0');
    if (cmp(A, B)) {
        auto C = sub(A , B);//调用函数，返回和存入数组C。auto编译器自己推断类型等价于 vector<int> C
        for (int i = C.size() - 1; i >= 0; i --) printf("%d", C[i]);//遍历输出C中元素即为两数差
    } else {//当A<B时计算B-A在前边添加负号即可
        auto C = sub(B, A);
        printf("-");
        for(int i = C.size() - 1; i >= 0; i --) {
          printf("%d",C[i]);
        }
    }
    return 0;
}
```

#### 高精度乘低精度 A*a len(A) <= 10^6 a <= 10^9

1. A的每一位乘a
2. 当前位为(A *a + 进位) % 10，进位为（A* a + 进位）/ 10
3. 不要忘记处理最后的进位

##### 高精度乘低精度模板：

```cpp
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

##### ACWING:793

```cpp
/*793.高精度乘法
给定两个非负整数（不含前导 0） A 和B ，请你计算 A × B 的值。
输入格式
共两行，第一行包含整数 A ，第二行包含整数B 。
输出格式
共一行，包含 A × B 的值。
数据范围
1 ≤ A 的长度 ≤ 100000 , 1≤A的长度≤100000,1≤A的长度≤100000,
0 ≤ B ≤ 10000 0≤B≤100000≤B≤10000
输入样例：
2
3
输出样例：
6*/
/*本题名为高精度乘法，实为高精度整数与普通整数相乘，而并非两个高精度整数相乘，故难度有所降低。
类似于高精度加法，本题从低位至高位将高精度整数每一位乘以普通整数。每次计算得到的结果由几部分相加构成：从低位来的进位、本位相乘结果
得到的结果又分为个位和高位两个部分：个位直接存进结果中，作为乘积结果中对应位的值；高位则继续保留，留至后面的位计算时处理。
如此循环往复，当高精度整数每一位均处理完后，将高精度整数最高位计算的进位一并存入结果中。
最后筛除前导0，得出乘积结果。若理解有困难，自行模拟乘法过程即可。*/
#include <iostream>
#include <string>
#include <vector>
using namespace std;
vector<int> mul(vector<int> a, int b) {
    vector<int> c;
    int num = 0; //用来存放临时计算结果
    for (int i = 0; i < a.size() || num != 0; i ++ )
    {
        if (i < a.size()) num += a[i] * b;
        c.push_back(num % 10);
        num /= 10;
    }
    //筛除前导0
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}

int main() {
    string A;
    int b;
    cin >> A >> b;
    //用vector存储高精度整数
    vector<int> a, c;
    for (int i = A.size() - 1; i >= 0; i -- ) a.push_back(A[i] - '0');
    //进行乘法过程
    c = mul(a, b);
    //输出乘法结果
    for (int i = c.size() - 1; i >= 0; i -- ) cout << c[i];
    return 0;
}
```

力扣 题b范围太大无法通过

#### 高精度除以低精度 A/B

- 从最高位开始算
- 余数为余数乘10 + 当前位
- 当前结果为 余数/b
- 余数为 当前余数%b
- 去除前导0

##### 高精度除以低精度模板：

```cpp
/*794.高精度除法
给定两个非负整数（不含前导 00） A，BA，B，请你计算 A/BA/B 的商和余数。
输入格式
共两行，第一行包含整数 AA，第二行包含整数 BB。
输出格式
共两行，第一行输出所求的商，第二行输出所求余数。
数据范围
1≤A的长度≤1000001≤A的长度≤100000,
1≤B≤100001≤B≤10000,
BB 一定不为 00
输入样例：
7
2
输出样例：
3
1
*/
/*思路
按照除法的法则
设置余数r
r一开始初始化为0
由于除法是从高位开始计算的 所以结果也是从高位开始存储的（结果需要反转）
r = r * 10 + Ai
商就是r / 10
反而余数r = r % 10 对于下一个A[i]进行计算*/
#include <iostream>
#include <algorithm>
using namespace std;
//A/b   商是c，余数r
vector<int> div(vector<int> &A,int b, int &r)//r是引用
{
    vector<int> C; //商是C，用vector<int>型存储商
    r =0;//r控制每次计算的余数
    for(int i =A.size()-1; i>=0; i--)//除法运算过程
    {
        r= r* 10+A[i];//余数*10+下一位作为下次被除数
        C.push_back(r/b);//输出商
        r %=b;//计算r下一次运算的值
    }
    reverse(C.begin(),C.end());
    while(C.size()>1 && C.back() ==0) C.pop_back();
    //去掉前导0当商为1时不去除即C.size()>1
    return C;
}
int main()
{
    string a;//高精度数a存为字符串
    int b;//较小数b
    cin >>a >> b;//输入两数
    vector<int> A;//定义数组A
    for(int i =a.size() -1; i>=0; i--) 
        A.push_back(a[i]-'0');//在A数组中正序添加高精度数a
    int r;
    auto C = div(A,b,r);//调用函数计算商
    for(int i =C.size() -1;i>=0;i--) 
        printf("%d",C[i]);
    cout << endl << r <<endl;//输出余数r
    return 0;
}
```

##### ACWING:794

```cpp
/*794.高精度除法
给定两个非负整数（不含前导 00） A，BA，B，请你计算 A/BA/B 的商和余数。
输入格式
共两行，第一行包含整数 AA，第二行包含整数 BB。
输出格式
共两行，第一行输出所求的商，第二行输出所求余数。
数据范围
1≤A的长度≤1000001≤A的长度≤100000,
1≤B≤100001≤B≤10000,
BB 一定不为 00
输入样例：
7
2
输出样例：
3
1
*/
/*思路
按照除法的法则
设置余数r
r一开始初始化为0
由于除法是从高位开始计算的 所以结果也是从高位开始存储的（结果需要反转）
r = r * 10 + Ai
商就是r / 10
反而余数r = r % 10 对于下一个A[i]进行计算*/
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
//A/b   商是c，余数r
vector<int> div(vector<int> &A,int b, int &r)//r是引用
{
    vector<int> C; //商是C，用vector<int>型存储商
    r =0;//r控制每次计算的余数
    for(int i =A.size()-1; i>=0; i--)//除法运算过程
    {
        r= r* 10+A[i];//余数*10+下一位作为下次被除数
        C.push_back(r/b);//输出商
        r %=b;//计算r下一次运算的值
    }
    reverse(C.begin(),C.end());
    while(C.size()>1 && C.back() ==0) C.pop_back();
    //去掉前导0当商为1时不去除即C.size()>1
    return C;
}
int main()
{
    string a;//高精度数a存为字符串
    int b;//较小数b
    cin >>a >> b;//输入两数
    vector<int> A;//定义数组A
    for(int i =a.size() -1; i>=0; i--) 
        A.push_back(a[i]-'0');//在A数组中正序添加高精度数a
    int r;
    auto C = div(A,b,r);//调用函数计算商
    for(int i =C.size() -1;i>=0;i--) 
        printf("%d",C[i]);
    cout << endl << r <<endl;//输出余数r
    return 0;
}
```

### 前缀和（核心：求和）

**下标从1开始，好处理边界问题**

#### 一维前缀和

> 前缀和是指数组中前 i 项的和，通常用 sum i 表示。
> 我们设 a 是原数组：sum i = a1 + a2 +a3 + ... + ai。

- 如何求：Si = a1+a2+...+ai
- 作用:求出一段的和
  - [l,r] = Sr - Sl-1
- 定义：
  - S0 = 0
  - Si = Si-1 + ai

前缀和算法一般用来处理区间和问题。

<img src="https://cdn.acwing.com/media/article/image/2022/07/29/125398_40bb4fea0f-%E5%89%8D%E7%BC%80%E5%92%8C.png" style="zoom:40%;" />

##### 一维前缀和模板：

```cpp
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

首先做一个预处理，定义一个`sum[]`数组，`sum[i]`代表`a`数组中前`i`个数的和。

##### 求前缀和运算：

```cpp
const int N=1e5+10;
int sum[N],a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];
for(int i=1;i<=n;i++)
{  
    sum[i]=sum[i-1]+a[i];   
}
```

然后查询操作：

```cpp
scanf("%d%d",&l,&r); printf("%d\n", sum[r]-sum[l-1]);
```

对于每次查询，只需执行`sum[r]-sum[l-1]` ，时间复杂度为`O(1)`

**原理**

`sum[r] =a[1]+a[2]+a[3]+a[l-1]+a[l]+a[l+1]......a[r]`;
`sum[l-1]=a[1]+a[2]+a[3]+a[l-1]`;
`sum[r]-sum[l-1]=a[l]+a[l+1]+......+a[r]`;

这样，对于每个询问，`只需要执行 sum[r]-sum[l-1]`。输出原序列中从第`l`个数到第r个数的和的时间复杂度变成了`O(1)`。

ACWING:795

```cpp
/*795.前缀和
输入一个长度为 nn 的整数序列。
接下来再输入 mm 个询问，每个询问输入一对 l, r。
对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。
输入格式
第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数数列。
接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。
输出格式
共 m 行，每行输出一个询问的结果。
数据范围
1≤l≤r≤n,
1≤n,m≤100000
−1000≤数列中元素的值≤1000
输入样例：
5 3
2 1 3 6 4
1 2
1 3
2 4
输出样例：
3
6
10
*/
#include<iostream>
using namespace std;
const int N = 1e5+10;
int n, m;
int a[N], s[N];
int main() {
    scanf("%d%d", &n, &m);//大数据输入scanf快一倍
    for(int i = 1; i <= n; i ++) { 
        scanf("%d", &a[i]);
    }
    for(int i = 1; i <= n; i ++) {//前缀和的初始化
        s[i]=s[i - 1] + a[i];
    }
    while(m -- ) { 
        int l,r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]);//区间和的计算
    }
    return 0;
}
```

*ios*::sync_with_stdio(false);//提高cin读取速度，不能使用scanf

```cpp
#include<iostream>
using namespace std;
const int N=1e5+10;
int a[N],sum[N];
int main() {
    ios::sync_with_stdio(false);//提高cin读取速度，不能使用scanf
    int n,m,x;
    cin>>n>>m;
    for(int i=1;i<=n;i++) {
        cin>>x;
        sum[i]=x+sum[i-1];
    }
    while(m--) {
        int l,r;
        cin>>l>>r;
        cout<<sum[r]-sum[l-1]<<endl;
    }
    return 0;
}
```

#### 二维前缀和：

求二维前缀和

<img src="https://cdn.acwing.com/media/article/image/2022/08/04/125398_aaf29dba13-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png" style="zoom:50%;" />

- Sij：左上所有元素的和

```dts
S_ {ij} = S_ {(i-1)j} + S_ {i(j-1)} -  S_ {(i-1)(j-1)} +  a_ {ij}
```

求任意子矩阵和<img src="https://cdn.acwing.com/media/article/image/2022/08/04/125398_d448a74113-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C2.png" style="zoom:50%;" />

- (x1,y1)到(x2,y2)的所有元素和

```llvm
S_ {x1,y1->x2,y2} = S_ {x2,y2} + S_ {x2,y1-1} -  S_ {x1-1,y2} +  S_ {x1-1,y1-1}
```

##### 二维前缀和模板：

```cpp
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

类似于前缀和,见 ACWing 795. 前缀和（C++），即将其由一维扩展到二维。

二维前缀和的每项可由公式求得：

```cpp
s[i][j]=s[i−1][j]+s[i][j−1]−s[i−1][j−1]+a[i][j]
```

对于每次的询问操作，子矩阵之和 sum 同样可直接用公式求得：

```cpp
sum=s[x2][y2]−s[x1−1][y2]−s[x2][y1−1]+s[x1−1][y1−1]
```

将矩阵存储至二维数组中时下标从1开始，这样做有两点好处：

1. 使得在进行求子矩阵和的操作过程中行列数与数组中行列数完全对应；
2. 注意到求解过程中出现 x 1 − 1 , y 1 − 1 x1 - 1,y1 - 1x1−1,y1−1 等数，若是从 0 00 开始，则为避免数组越界（出现 s [ − 1 ] s[-1]s[−1] 等值）,对于这些情况需要重新讨论，增加了程序复杂程度。

##### ACWING:796

```cpp
/*796.子矩阵的和
输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。
对于每个询问输出子矩阵中所有数的和。
输入格式
第一行包含三个整数 n，m，q
接下来 n nn 行，每行包含 m mm 个整数，表示整数矩阵。
接下来 q qq 行，每行包含四个整数 x1, y1, x2, y2，表示一组询问。
输出格式
共 q 行，每行输出一个询问的结果。
数据范围
1 ≤ n , m ≤ 1000 , 
1 ≤ q ≤ 200000 ,
1 ≤ x 1 ≤ x 2 ≤ n ,
1 ≤ y 1 ≤ y 2 ≤ m ,
− 1000 ≤ 矩阵内元素的值 ≤ 1000
输入样例：
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
输出样例：
17
27
21
*/
#include<iostream>
using namespace std;
const int N=1010;
int n, m, q;
int a[N][N], s[N][N];
int main(void) {
    scanf("%d%d%d",&n,&m,&q);
    for(int i = 1; i <= n; i ++) {
        for(int j = 1;j <= m; j ++) {
            scanf("%d", &a[i][j]);
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; //求二维前缀和
        }
    }
    while( q-- ) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]); //求任意子矩阵和
    }
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;
const int N = 1010;
int n, m, q;
int a[N][N], sum[N][N];
int x, y, xx, yy;
int main() {
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i ++ ) {
        for (int j = 1; j <= m; j ++ ) {
            cin >> a[i][j];
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]; //求二维前缀和
        }
    }
    while (q -- ) {
        cin >> x >> y >> xx >> yy;
        cout << sum[xx][yy] - sum[x - 1][yy] - sum[xx][y - 1] + sum[x - 1][y - 1] << endl; //求任意子矩阵和
    }
    return 0;
}
```



### 差分（核心：构造子序列）前缀和的逆运算

#### 一维差分

应用：在一个数组a[]的指定区间[l,r]上每个数都加上c

- 构造出b[](b[i] = a[i] - a[i - 1])，a是b的前缀和
- 要a在[l,r]上的每个数都加c
- b[l] += c
- b[r+1] -=c
- 对b求前缀和，得到要的a

假定a: a1,a2,a3...,an是数组b: b1,b2,b3...,bn的前缀和数组，那么称b是a的差分数组。即ai = b1+b2+b3+...+bi。（反过来可以推出b1=a1,b2=a2-a1,b3=a3-a2...,bn=an-an-1）(差分其实就是前缀和的逆运算)

差分有什么用呢，首先可以在O(n)的时间内，由b数组得到a数组，**重点**：让数组a某段（l,r）每个元素都加上（连续加多次）某一值的操作从O(n)->O(1)，只需要将b[l]+c,b[r+1]-c。

首先我们要考虑如何初始化差分数组，然而对于差分数组来说，我们不需要单独考虑如何构造，只需要考虑如何更新（把初始化也当成更新）。

**重点**：我们来看下为什么可以把初始化也当成更新操作，首先你假设a数组全为0，则差分数组b也全为0。现在你要做的更新操作就是在数组a[1,1]，[2,2]，[3,3]...的范围依加上a1,a2,a3...，则相当于在数组b[1]+a1,b[2]-a1、b[2]+a2,b[3]-a2、...

##### 一维差分模板：

```cpp
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

差分就是前缀和的逆运算，我们可以将一个数组构建为差分数组a，使得其前缀和就是原始数组，如果我们要在区间[l ,r] 上加上某一个数c，其实我们就相当于我们在差分数组中对a[l] += c, a[r + 1] -= c。这样最后的时候求一遍前缀和就可以得出最后的数组了

##### ACWING:797

```cpp
/*797.差分
给定一个长n的整数序列A，再进行m次操作，每次操作包含三个整数l,r,c表示将序列中的[l,r]每个数都增c 。输出操作完后的数列。区间的下标是从1开始计数的。
输入格式：
第一行包含两个整数n和m。第二行包含n个整数，表示整数序列。接下来m行，每行包含三个整数l，r，c表示一个操作。
输出格式：
共一行，包含n个整数，表示最终序列。
数据范围：
1≤n,m≤100000
1 ≤ l ≤ r ≤ n
− 1000 ≤ c ≤ 1000 -1000
− 1000 ≤ A [ i ] ≤ 1000
样例输入：
输入：
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
输出：
3 4 5 3 4 2
*/
/*
思路是利用差分数组。求出差分数组d使得
A[i]=∑d[0:i]
真实代码中可以想象A一开始都是0，每次将A[i:i]增加一个数，而对于差分数组来说，原数组A[l:r]全体增加一个数c，效果是d[l]增加c，而d[r+1]减少c（如果r+1越界了那就忽略），这样方便编程。*/
#include <iostream>
using namespace std;
const int N = 100010;
int n, m;
int a[N],b[N];
void insert(int l, int r, int c){//插入函数
    b[l] += c;
    b[r + 1] -= c;
}
int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= n; i ++){
        insert(i, i, a[i]);
    }
    while (m --){
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        insert(l, r, c);
    }
    for (int i = 1; i <= n; i ++){
        b[i] += b[i - 1];
    }
    for (int i = 1; i <= n; i ++){
        printf("%d ", b[i]);
    }
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int a[N], d[N];
int n, m, l, r, c;
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) {
        d[i] += a[i]; 
        if (i + 1 < n)
            d[i + 1] -= a[i];
    }
    while (m--) {
        cin >> l >> r >> c;
        d[l - 1] += c;
        d[r] -= c;
    }
    int s = 0;
    for (int i = 0; i < n; i++) {
        s += d[i];
        printf("%d ", s);
    }
    return 0;
}
```

#### 二维差分

应用：对二维矩阵指定区间的所有值加上c

- 构造b[](bi = ai - ai - 1 - ai + ai - 1)
- 要a在[x1,y1]到[x2,y2]上的每个数都加c
- bi += c
- bi + 1 -= c
- bi -= c
- bi + 1 +=c

注意二维差分和二维前缀和的不同，二维前缀和是对给定点的左上角操作，而二维差分则是对右下角进行操作。如果记不清楚该加减的位置，可以画图，这样更直观准确。（这里可能不好理解初始化二维差分数组的操作，插入操作是指在原数组某一范围插入一个数而要改变差分数组的哪些值的操作，当你在模拟在原始数组的每个点插入相对应的数时（这个动作是在改变差分数组的值），就相当于初始化差分数组）

##### 二维差分模板：

```cpp
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

<img src="https://s2.loli.net/2023/02/11/u12RaJsjBmDQSbC.png" style="zoom: 40%;" />

其实这些数，都是在处理**二维前缀和的数+1**得到的

当对差分矩阵进行构造时，我们只需要对其每次的1x1小矩阵插入即可，原理和一维差分一致。当对差分矩阵进行多次子矩阵插入之后，可以通过**求二维前缀和**获得对应的矩阵。

##### ACWING:798

```cpp
/*输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中(x1,y1)和(x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上c。
请你将进行完所有操作后的矩阵输出。
输入格式
第一行包含整数n,m,q。
接下来n行，每行包含m个整数，表示整数矩阵。
接下来q行，每行包含5个整数x1,y1,x2,y2,c，表示一个操作。
输出格式
共n行，每行m个整数，表示所有操作进行完毕后的最终矩阵。
数据范围
1 ≤ n , m ≤ 1000 ,
1 ≤ q ≤ 100000 ,
1 ≤ x1 ≤ x2 ≤ n ,
1 ≤ y1 ≤ y2 ≤ m ,
− 1000 ≤ c≤ 1000 ,
− 1000 ≤ 矩阵内元素的值 ≤ 1000 
输入样例：
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
输出样例：
2 3 4 1
4 3 4 1
2 2 2 2
*/
#include <iostream>
using namespace std;
const int N = 1e3 + 10;//1010
int b[N][N];
int n, m, k;
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main() {
    scanf("%d%d%d", &n, &m, &k);
    // 初始化构造差分矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
              int x;
              scanf("%d", &x);
              insert(i, j, i, j, x);
          }
    }
    // 多次进行矩阵区域插入
    while (k--) {
        int x1, y1, x2, y2, c;
        scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &c);
        insert(x1, y1, x2, y2, c);
    }
    // 对差分矩阵求二维前缀和
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            printf("%d ", b[i][j]);
        }
        puts("");
    }
    return 0;
}
```



**Day5**.(2023.2.12)

### 双指针：

- 两个序列两个指针
- 一个序列首尾指针
- 核心思想：O（n ^ 2） -> O(n)
- i是左指针

双指针算法有两大类，第一大类是分别指向两个数组，第二大类是同时指向一个序列。

双指针算法一般都可以从暴力的角度着手（看下i和j有没有什么单调关系），从而将算法复杂度从o(n^2)降低到o(n)。

#### 双指针模板:

```cpp
for (int i = 0, j = 0; i < n; i ++ )//后指针不断更新
{
    while (j < i && check(i, j)) j ++ ;//不满足条件，前指针更新
    
    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

基本运用：

#### 输出单个字符

```cpp
#include <iostream>
#include <string.h>
using namespace std;
int main() {
    char str[1000];
    gets(str);
    int n = strlen(str);
    for (int i = 0; i < n; i ++) {
        int j = i;
        while(j < n && str[j] !=' ') j ++;
        //这道题的具体逻辑
        for (int k = i; k < j; k ++) cout << str[k];
        cout << endl;
        i = j;
    }
    return 0;
}
```

##### ACWING:799

朴素做法：双重循环，对区间 [ i , j ] 进行重复性检查。i 可以遍历所有的终点情况，j 结束循环是已找到对于终点 i 最远的起点，之后对所有终点情况取最小值即可。此做法时间复杂度为 O(n^2)。

```cpp
	//i是区间终点，j是区间起点
	for (int i = 0; i < n; i ++ ) {
		for (int j = 0; j <= i; j ++ ) {
			//check函数检查i, j之间有无重复数
			if (check(i, j) == 0) break;
		}
		res = min(res, i - j + 1);
	}
```

改进方法：双指针算法
注意到，随着 i 的增加，j 的值不可能减少。因为区间 [ j , i ] 已经出现重复元素，所以区间 [ p , q ] ( p < j , i < q ) 中也必然出现重复元素，故 j 的值无需每次循环都回溯到 0，而是在全过程中单调不减的。由此，可以使用如下的双指针算法：

```cpp
    for (int i = 0, j = 0; i < n; i ++ ) {
        s[a[i]] ++;
        while (s[a[i]] > 1) s[a[j ++]] --;
        res = max(res, i - j + 1);
    }
```

完整代码：

```cpp
/*799.最长连续不重复子序列
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
输入格式
第一行包含整数 n。
第二行包含 n 个整数（均在 0 ∼ 10^5 范围内），表示整数序列。
输出格式
共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围
1 ≤ n ≤ 10^5
输入样例：
5
1 2 2 3 5
输出样例：
3
*/
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], s[N]; //a[i]用来存放原序列,s[i]用来存放区间中各数字出现次数
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    int res = 0;
    for (int i = 0, j = 0; i < n; i ++ ) {
        s[a[i]] ++; //a[i]出现次数加1
        while (s[a[i]] > 1) s[a[j ++]] --; //起点右移，直至没有区间内没有重复
        res = max(res, i - j + 1);
    }
    cout << res << endl;
    return 0;
}
```



### 位运算：

位运算一般有两个作用：

1. n的二进制表示中第k位是几(n>>k&1)。

2. lowbit操作（这道题好像是返回最右边的1所代表的数，树状数组的一个基本操作）

   二进制数：最后一位1-->最后

   ​	x = 1010 lowbit(x) = 10

   ​	x = 101000				1000

   <img src="https://s2.loli.net/2023/02/12/IHXWTt87lnzONfC.png" style="zoom:40%;" />

   ```cpp
   #include <iostream>
   using namespace std;
   int main() {
       int n = 10;
       for(int k = 3; k >= 0; k --) cout << (n >> k & 1);
       return 0;
   }
   ```

   <img src="https://s2.loli.net/2023/02/12/AKotriHxdTO9zqY.png" alt="" style="zoom:40%;" />

   

   它的功能是可以统计x里面1的个数（每次都把最后一个1去掉，减了多少次就有多少个1）

   <img src="https://s2.loli.net/2023/02/12/XU6bHhPWoiZ93mS.png" style="zoom:40%;" />

```cpp
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n
```

#### 位运算-二进制表示：

- 先把第k位移到最后一位 n >> k
- 看个位是几 & 1
- n >> k & 1(相当于与000001)

```cpp
#include <iostream>
using namespace std;
int main() {
    int n = 10;
    for(int k = 3; k >= 0; k --) cout << (n >> k & 1);
    return 0;
}
```

#### lowbit(x)：

- eg：x = 101000 lowbit(x) = 1000
- lowbit(x)实现：x & -x
- 应用：统计1的个数
- eg：x -= lowbit(x) ans++;

##### ACWING:801

```cpp
/*给定一个长n的数列A，求每个数的二进制表示中1的个数。
输入格式：
第一行包含整数n。第二行包含n个整数，表示整个数列。
输出格式：
共一行，包含n个整数，其中的第i个数表示数列中的第i个数的二进制表示中1的个数。
数据范围：
1 ≤ n ≤ 100000
0 ≤ A [i] ≤ 10^90
可以用lowbit来做*/
#include <iostream>
using namespace std;
int lowbit(int x) {
    return x & -x;
}
int main() {
    int n;
    cin >> n;
    while (n --) {
        int x, cnt = 0;
        cin >> x;
        while (x) {// 直至删到 0 为止 
            x -= lowbit(x); // 进行更新操作在二进制表示中将最后一位 1 至最低位的部分删掉
            cnt ++;
        }
        cout << cnt << ' '; // 输出删除的次数，即二进制表示中 1 的个数
    }
    return 0;
}
```

下面解释下为什么在计算机中用补码表示负数（最后一步手工带入x算）：

<img src="https://s2.loli.net/2023/02/12/MP6HWhAZfTk4BNG.png" style="zoom:40%;" />





### 离散化：

> 这里特指整数离散化，而且是有序的离散化（它的值域跨度很大，但是很稀疏）

- 思想：将0~10^9的n个不连续值映射到0，1，2，3 ... n-1
- eg：1，20，50000 -> 0，1，2
- 应用：值的跨度大，真正用到的数很少（AcWing 802）
- 排序
- 去重 alls.erase(unique(alls.begin(), alls.end()), alls.end());
- unique()将重复元素放到后面，返回下标
- 二分查找对应离散化值

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230212203954537.png" style="zoom:40%;" />

#### 离散化模板：推荐使用C++STL库函数

```cpp
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

##### ACWING:802

```cpp
/*802.区间和
假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。
现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。
接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。
输入格式
第一行包含两个整数 n 和 m。
接下来 n 行，每行包含两个整数 x 和 c。
再接下来 m 行，每行包含两个整数 l 和 r。
输出格式
共 m 行，每行输出一个询问中所求的区间内数字和。
数据范围
−10^9 ≤ x ≤ 10^9,
1 ≤ n,m ≤ 10^5,
−10^9 ≤ l ≤ r ≤ 10^9,
−10000 ≤ c ≤ 10000
输入样例：
3 3
1 2
3 6
7 5
1 3
4 6
7 8
输出样例：
8
0
5
*/
//离散化
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int n,m;
const int N = 300010;
//设置一个离散数据连续化之后存储add操作数据的数组a[N]，以及其前缀和数组s[N]
int a[N],s[N];
//定义一个vector数组把所有题目中操作涉及到的下标存储进去
vector<int>alls;
//定义一个数对类型来表示每次的加c操作和询问
typedef pair<int,int> PII;
//设置一个vector数组来存储每次的加c操作和询问操作的数对（数对作为一个基本元素,vector数组是存储若干个这样的数对）
vector<PII>add, query;
//默写一下二分模板 待会要用
int find(int x) {
    int l = 0,r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;//也可以返回r r+1是将数据离散化成1,2,3,4...n(从1开始，而不是从0开始)
}
int main() {
    cin >> n >> m;
    //现在开始循环执行n次加c操作，初始化add和alls数组
    for (int i = 0; i < n; i ++) {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    //现在开始循环执行m次询问操作，初始化query和alls数组
    for (int i = 0; i < m; i ++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //然后我们开始对alls数组进行排序和去重
    //这里补充一下，alls数组存在的意义其实为了将下标排序，看每次的l和r之间有哪些x是在里面的
    //这些离散的x在连续化映射之后得到的值就会作为之后利用a[N]前缀和求和的下标依据
    sort(alls.begin(),alls.end());//排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());//去重。unique函数是ctl中自带的函数
    //现在我们开始处理并统计数轴中经过add操作之后不是0的那些部分
    //也就是初始化a数组，把原来数轴中不为0的那些位置上的数字统计过来
    //存储的下标x依据就是利用二分来寻找其在alls数组中的相对位置
    for (auto item:add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    //预处理前缀和，这一步是用来求最后[l,r]区间的依据
    for (int i = 1; i <= alls.size(); i ++) s[i] = s[i-1] + a[i];
    //处理询问
    for (auto item:query) {
        //item.first和item.second其实就是原来键盘中输入的每次询问的l和r
        //下面的l和r是经过映射之后的下标
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l-1] << endl;
    }
    return 0;
}
```

自行实现迭代器：

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int n,m;
const int N = 300010;
//设置一个离散数据连续化之后存储add操作数据的数组a[N]，以及其前缀和数组s[N]
int a[N],s[N];
//定义一个vector数组把所有题目中操作涉及到的下标存储进去
vector<int>alls;
//定义一个数对类型来表示每次的加c操作和询问
typedef pair<int,int> PII;
//设置一个vector数组来存储每次的加c操作和询问操作的数对（数对作为一个基本元素,vector数组是存储若干个这样的数对）
vector<PII>add, query;
//默写一下二分模板 待会要用
int find(int x) {
    int l = 0,r = alls.size() - 1;
    while (l<r) {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;//也可以返回r r+1是将数据离散化成1,2,3,4...n(从1开始，而不是从0开始)
}
vector<int>::iterator unique(vector<int> &a) {
    int j = 0;
    for (int i = 0; i < a.size(); i ++) {
        if(!i || a[i] != a[i - 1]) {
            a[j ++ ] = a[i];
        }
    }
    // a[0] ~ a[j - 1] 所有a中不重复的数
    return a.begin() + j;
}
int main() {
    cin >> n >> m;
    //现在开始循环执行n次加c操作，初始化add和alls数组
    for (int i = 0; i < n; i ++) {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    //现在开始循环执行m次询问操作，初始化query和alls数组
    for (int i = 0; i < m; i ++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //然后我们开始对alls数组进行排序和去重
    //这里补充一下，alls数组存在的意义其实为了将下标排序，看每次的l和r之间有哪些x是在里面的
    //这些离散的x在连续化映射之后得到的值就会作为之后利用a[N]前缀和求和的下标依据
    sort(alls.begin(),alls.end());//排序
    alls.erase(unique(alls),alls.end());//去重。unique函数是ctl中自带的函数
    //现在我们开始处理并统计数轴中经过add操作之后不是0的那些部分
    //也就是初始化a数组，把原来数轴中不为0的那些位置上的数字统计过来
    //存储的下标x依据就是利用二分来寻找其在alls数组中的相对位置
    for (auto item:add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    //预处理前缀和，这一步是用来求最后[l,r]区间的依据
    for (int i = 1; i <= alls.size(); i ++) s[i] = s[i-1]+a[i];
    //处理询问
    for (auto item:query) {
        //item.first和item.second其实就是原来键盘中输入的每次询问的l和r
        //下面的l和r是经过映射之后的下标
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l-1] << endl;
    }
    return 0;
}
```



**Day5**.(2023.2.12)

### 区间合并：

>快速把n个区间有交集的快速合并

- 按区间左端点排序
- 扫描整个区间，将有交集的区间合并
- 如果右端点小于当前左边，更新左右端点
- 如果右端点大于等于当前左边，更新右端点

```cpp
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

#### ACWING:803

>依据新区间和维护区间是否有相交的部分，可以将上述 3 种情况视为 2 种情形。
>如果新区间的左端点 > 维护区间的右端点，则两个区间没有相交部分，则将维护区间的左右端点保存起来；
>如果新区间的左端点 <= 维护区间的右端点，则两个区间有相交部分，则更新维护区间的右端点，取两个区间右端点的最大值。

Tips

- pair++ 中，会优先对左端点进行从小到大的排序，再对右端点进行从小到大的排序。
- 将 vector 容器作为函数参数，使用引用传递的方式，在形式参数前加上 &，函数内部形参发生变化时，这种改变可以直接传递给被调用的实参。
- 注意边界 -2e9

```cpp
/*803.区间合并
给定n个区间[l, r]。
合并所有有交集的区间。
输出合并完成后的区间个数。
例如：[1,3]和[2,6]可以合并为一个区间[1,6]。
输入格式
第一行包含整数n。
接下来n行，每行包含两个整数 l 和 r。
输出格式
共一行，包含一个整数，表示合并区间完成后的区间个数。
样例
输入样例：
5
1 2
2 4
5 6
7 8
7 9
输出样例：
3
*/
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
int n;
vector<PII> segs;
void merge(vector<PII> &segs) {
  vector<PII> res;
  sort(segs.begin(), segs.end());
  int st = -2e9, ed = -2e9;
  for (auto seg : segs) {
      if (ed < seg.first) {
          if (st != -2e9) res.push_back({st, ed});
          st = seg.first, ed = seg.second;
      }
      else ed = max(ed, seg.second);
  }
  if (st != -2e9) res.push_back({st,ed});
  segs = res;
}
int main() {
    cin >> n;
    for(int i = 0; i < n; i ++) {
        int l, r;
        cin >> l >> r;
        segs.push_back({l,r});
    }
    merge(segs);
    cout << segs.size() <<endl;
    return 0;
}
```



**Day13.(2023.2.20)**

## 数据结构

### 链表与邻链表

一般我们接触到的链表都是动态链表，如下图所示，但是动态链表的创建是非常满的（new操作），很大概率就直接超时了，所以一般只有面试的时候才用，笔试的时候不用。

```cpp
struct Node
{
    int val;
    Node *next
}

new Node(); //非常慢
```

这里讲的是拿数组模拟链表（单链表：用的最多的是邻接表，n个单链表合起来，用于存储树或者图，双链表：优化某些问题）

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230220224836262.png" style="zoom: 43%;" />

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230221230541531.png" alt="插入操作（非头节点）" style="zoom:43%;" />

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230221230637732.png" alt="删除操作" style="zoom:43%;" />

#### 数组模拟单链表 静态链表

##### 单链表模板

```csharp
int head; //头节点
int e[N]; //值
int ne[N]; //next指针
int idx; //数组用到第几个点

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert_head(int a)
{
    e[idx] = a;
    ne[idx] = head;
    head = idx;
    idx++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}

// 将a插入到第k个点后面
void add(int k, int a)
{
    e[idx] = a;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx ++;
}
//将下标是k的后边的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
```

**Day14.(2023.2.21)**

##### ACWING:826

```cpp
/*826.单链表
实现一个单链表，链表初始为空，支持三种操作：
向链表头插入一个数；
删除第 k个插入的数后面的数；
在第 k个插入的数后插入一个数。
现在要对该链表进行 M次操作，进行完所有操作后，从头到尾输出整个链表。
注意:题目中第 k个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
输入格式
第一行包含整数 M，表示操作次数。
接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：
    H x，表示向链表头插入一个数 x。
    D k，表示删除第 k个插入的数后面的数（当 k 为 0时，表示删除头结点）。
    I k x，表示在第 k个插入的数后面插入一个数 x（此操作中 k 均大于 0）。
输出格式
共一行，将整个链表从头到尾输出。
数据范围
1≤M≤100000
所有操作保证合法。
输入样例：
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
输出样例：
6 4 6 5
*/
/*基本思想：
①将一个数x插到现有头结点之前
②将一个数x插到下标为k的数的后面一位
③删除一个节点
思路
用 a 数组代表数据域 ，然后 ne 数存储的是指针域。
创建一个链表即创建一个头指针，head = -1；
然后存储的数据个数是 idx 初始化即为 0 ；
插入操作即将第 k 和数据后面插入一个 x : 首先创建节点 a[idx] = x ; 然后将指针指向k后面的节点 ne[idx] = ne[k] ;
k 的指针再指向新的节点 ne[k] = idx ++ (加一是因为这样就不用再写一个idx++);
删除操作，因为是静态链表，不需要释放资源，直接将的要删除的数的前一个指针指向后一个，ne[k] = ne[ne[k]];
如果是头指针即 head = ne[haed];
头插：类似于插入只是将 j 换成了head ,创建节点： a[idx] = x;
指针指向头指针指向的数据ne[idx] = head ,头指针指向head = idx++;*/
#include<iostream>
using namespace std;
const int N = 100010;
//单链表
// head 头指针,描述第一个结点的索引,-1表示单链表结尾，初始化时链表为空，所有head指向tail=-1
// e[i] 表示节点i的值
// ne[i] 表示节点i的next指针是多少
// idx 存储当前已经用到了哪个点
int head, e[N], ne[N], idx;
// 初始化
void init() {
    head = -1;
    idx = 0;//一开始位0
}
/**
 * 功能：向链表头插入一个数
 * @param x
 */
void add_to_head(int x) {
    /*四步法
     1、存值
     2、将头指针指向的结点标识为下一个结点
     3、将头指针指向当前结点
     4、idx++准备下一个可用的索引号
    */
    e[idx] = x, ne[idx] = head, head = idx++;
}
/**
 * 功能：将x插到下标是k的点后面
 * @param k
 * @param x
 */
void add(int k, int x) {
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;
}
/**
 * 功能：将下标是k的点后面的点删掉
 * 比如想删除第k个结点，那么需要传入k-1,因为k-1的下一个结点才是k
 * @param k
 */
void remove(int k) {
    ne[k] = ne[ne[k]];
}
int main() {
    //优化输入
    ios::sync_with_stdio(false);
    //m次操作
    int m;
    cin >> m;
    init();//初始化
    while (m--) {
        int k, x;
        char op;
        cin >> op;
        //头插法:x
        if (op == 'H') {
            cin >> x;
            add_to_head(x);
        } else if (op == 'D') {
            //表示删除第k个插入的数后面的数（当k为0时，示删除头结点）。
            cin >> k;
            //删除头结点需要特判，否则会丢失关系
            if (k == 0) head = ne[head];//或if (!k) 
            //第k个插入的数，那么在数组中下标是k-1,所以调用时需要使用remove(k-1,x)
            else remove(k - 1);
        } else {
            //在第k个插入的数后插入一个数
            cin >> k >> x;
            //第k个插入的数，那么在数组中下标是k-1,所以调用时需要使用add(k-1,x)
            add(k - 1, x);
        }
    }
    //遍历单链表
    for (int i = head; i != -1; i = ne[i])cout << e[i] << " ";
    return 0;
}
```



**Day15.(2023.2.22)**

#### 数组模拟双链表（优化某些问题）

每一个点有两个指针

用下标为0的点表示头节点（左端点），为1的表示尾节点（右端点）

<img src="https://img2022.cnblogs.com/blog/2425439/202205/2425439-20220511115451090-15263877.png" style="zoom: 43%;" />

Left：左端点，right，右端点。这两个不算在链表里，所以在最左侧插入数就是在left右边插入。

为什么单链表用了头节点head，而双链表直接用01表示两端，这是因为大部分题目就用这样的操作可以解决。

0是左端点，因此r[0]=1, 1是右端点，l[1]=0

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230222091524768.png" alt="" style="zoom:38%;" />

现在写的是在k的右边插入一个点，如果想在k的左边插入一个点，可以写成add(l[k],x)

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230222125157324.png" style="zoom:38%;" />

这个是删除操作。

拿邻接表存储树和图放到第三章讲，这个双链表确实很难理解，只有自己多画图，然后结合着代码理解。

##### 双链表模板：

```csharp
int e[N];
int l[N];
int r[N];

//初始化
void init()
{
    // 0表示左端点（head）， 1表示右端点（tail）
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

//在下标是k的点的右边，插入x
void add(int k, int x)
{
    e[idx] = x;
    r[idx] = r[k]; //不能用 k + 1
    l[idx] = k;
    
    l[r[k]] = idx; //不能用 k + 1
    r[k] = idx;
    
}

//在k的左边插入x
add(l[k], x);

//删除第k个点
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}
```

##### ACWING:827

```cpp
/*双链表
实现一个双链表，双链表初始为空，支持5种操作：
在最左侧插入一个数；
在最右侧插入一个数；
将第 k个插入的数删除；
在 第 k个插入的数左侧插入一个数；
在第 k个插入的数右侧插入一个数
现在要对该链表进行 M次操作，进行完所有操作后，从左到右输出整个链表。
注意:题目中第 k个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n个插入的数。
输入格式
第一行包含整数 M，表示操作次数。接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：
L x，表示在链表的最左端插入数 x。
R x，表示在链表的最右端插入数 x。
D k，表示将第 k个插入的数删除。
IL k x，表示在第 k个插入的数左侧插入一个数。
IR k x，表示在第 k个插入的数右侧插入一个数。
输出格式
共一行，将整个链表从左到右输出。
数据范围
1≤M≤100000
所有操作保证合法。
输入样例：
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
输出样例：
8 7 7 3 2 9
*/
/*思路：
开三个数组
e[]用来存储数值
l[]用来存储前驱（左边数的下标）
r[]用来存储后继（右边数的下标）
idx用来记录当前下标
定义几个函数然后调用函数接着就ac了~*/
#include<bits/stdc++.h>
using namespace std;
const int N =1e5+10;
int e[N],r[N],l[N],idx;
//e用来存储数值，l[]用来存储前驱（左边数的下标），r[]用来存储后继（右边数的下标），idx用来记录当前下标
void init() {//初始化
    //0是左端点，1是右端点 
    r[0]=1;
    l[0]=0;
    idx=2;
} 
void add_to_right(int k,int x) {//在k右边插入x
    e[idx]=x;//将x存入当前下标的数值数组中 
    r[idx]=r[k];//当前下标的后继为k的后继 
    l[idx]=k;//当前下标的前驱为k 
    l[r[k]]=idx;//k的后继节点的前驱为idx 
    r[k]=idx++; //k的后继节点为idx； idx++； 
} 
void add_to_left(int k,int x) {//在k的左边插入x 
  	add_to_right(l[k],x);//等价于在k的前驱的右边插入x 
}
void remove(int k)  {//删除第k个结点
  	r[l[k]]=r[k];//k的前驱的后继为k的后继
	  l[r[k]]=l[k];//k的后继的前驱为k的前驱 
}   
void add_to_head(int x ) {//在链表的最左端插入数x
   	add_to_right(0,x);//在0的后面插入x 
} 
void add_to_tail(int x)	{//在链表的最右端插入数x
		add_to_right(l[1],x);
} 
int main() {
		int m;
		init();
		scanf("%d",&m);
		while(m--) {
        string c;
        cin>>c;
        if(c=="L") {
            int x;
            scanf("%d",&x);
            add_to_head(x);
        }else if(c=="R") {
            int x;
            scanf("%d",&x);
            add_to_tail(x);
        }else if(c=="D") {
            int k;
            scanf("%d",&k);
            remove(k+1);
        }else if(c=="IL") {
            int k,x;
            scanf("%d%d",&k,&x);
            add_to_left(k+1,x);
        }else {
            int k,x;
            scanf("%d%d",&k,&x);
            add_to_right(k+1,x);
        }
    } 
    for(int i=r[0];i!=1;i=r[i]) {
        printf("%d ",e[i]);
    }
    printf("\n");
    return 0;
} 
```



**Day16.(2023.2.23)**

#### 邻接表 存储树和图

![](https://segmentfault.com/img/remote/1460000039206214)

![](https://segmentfault.com/img/remote/1460000039206215)



### 栈与队列（吐出来的是栈，拉出来的是队列）

刷题 acwing 828的时候看到x的范围是在1<=x<=10^9，就看了下c++整型，长整型的表示范围。

signed int 4B，(-2^32)/2 -> (2^32)/22-1 （长度是10位）

signed long 4B, (-2^32)/2 -> (2^32)/22-1 （长度是10位）

signed long long 8B. (-2^64)/2 -> (2^64)/22-1

首先学习用数组来模拟栈和队列：

#### 数组模拟栈：先进后出，从队尾插入队尾取出

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

##### ACWING:828

```cpp
/*828.模拟栈
实现一个栈，栈初始为空，支持四种操作：
1. push x – 向栈顶插入一个数 x；
2. pop – 从栈顶弹出一个数；
3. empty – 判断栈是否为空；
4. query – 查询栈顶元素。
现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4都要输出相应的结果。
输入格式
第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式
对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。
数据范围
1≤M≤100000
1≤x≤10^9
所有操作保证合法。
输入样例：
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
输出样例：
5
5
YES
4
NO
*/
/*用数组模拟实现：
①第一个元素时n == 1
②n是全局变量，初始值为0
③按照题目要求，三四两步最后加回车*/
#include <iostream>
using namespace std;
const int N=100010;
//tt是栈顶指针
int stk[N],tt;
void push(int x) {
    stk[tt]=x;
    tt++;
}
void pop() {
    tt--;
}
bool empty() {
    if(tt==0) return true;
    else return false;
}
int query() {
    if(!empty()) return stk[tt-1];
}
int main() {
    tt = 0;
    int m;
    cin >> m;
    string s;
    int x;
    while(m--) {
        cin>>s;
        if(s=="push") {
            cin>>x;
            push(x);
        }else if(s=="pop") {
            pop();
        }else if(s=="empty") {
            bool tmp=empty();
            if(tmp) cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
        }else {
            cout<<query()<<endl;
        }
    }
    return 0;
}
```

#### 数组模拟队列：先进先出，在队尾插入，队头取出

```cpp
//1. 普通队列：
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}

//2. 循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}

```

##### ACWING:829

```cpp
```



### 单调栈和单调队列（优化暴力，去掉中间没有用的元素，剩下元素有单调性可以做优化）

#### 单调栈：求滑动窗口最大值、最小值

eg：（左\右边有没有大\小的数） 变成严格单调上升的栈

给定一个序列，让我们求序列中的每个数的 左边离他最近的，且比它小的数（单调队列也一样）先想暴力解法，然后怎么优化（弄个单调序列出来）。

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230223211156510.png" style="zoom:60%;" />

当把左边比右边大的数删掉后，会变成一个严格单调上升的栈。

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230223211241755.png" style="zoom:60%;" />

##### ACWING:836

```cpp
/*830.单调栈
给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。
输入格式
第一行包含整数N，表示数列长度。
第二行包含N个整数，表示整数数列。
输出格式
共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。
数据范围
1≤N≤105 1≤数列中元素≤109
输入样例：
5 3 4 2 7 5
输出样例：
-1 3 -1 2 2*/
/**/
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;
int main() {
    int n;
    cin >> n;
    while (n -- ) {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) //当栈是不空的并且栈里的元素是大于当 前这个数字的，那么栈里的元素就不会被用到   
            tt -- ;
        if (!tt) printf("-1 ");//如果都大于，说明没有，就输出-1 
        else printf("%d ", stk[tt]);//如果存在小于的，就输出 
        stk[ ++ tt] = x;//然后把x放进去 
    }
    return 0;
}
```

#### 单调队列

eg：求滑动窗口的最大值\最小值

q里面装的是数组a的下标，hh指的是当前滑动窗口最小值的下标存储在q中的哪个位置，tt指的是当前滑动窗口（去除掉左边比右边大的数后，严格单调上升）的尾端（即当前滑动窗口转换成严格单调上升后最大数的下标）在q的哪个位置。

##### ACWING:154

```cpp
/*154.滑动窗口
给定一个大小为 n≤10^6的数组。
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 [1 3 -1 -3 5 3 6 7]，k
为 3 。
窗口位置	最小值	最大值
[1 3 -1] -3 5 3 6 7	-1	3
1 [3 -1 -3] 5 3 6 7	-3	3
1 3 [-1 -3 5] 3 6 7	-3	5
1 3 -1 [-3 5 3] 6 7	-3	5
1 3 -1 -3 [5 3 6] 7	3	6
1 3 -1 -3 5 [3 6 7]	3	7
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
输入格式
输入包含两行。
第一行包含两个整数 n
和 k ，分别代表数组长度和滑动窗口的长度。
第二行有 n 个整数，代表数组的具体数值。
同行数据之间用空格隔开。
输出格式
输出包含两个。
第一行输出，从左至右，每个位置滑动窗口中的最小值。
第二行输出，从左至右，每个位置滑动窗口中的最大值。
输入样例
8 3
1 3 -1 -3 5 3 6 7
输出样例
-1 -3 -3 -3 3 3
3 3 5 5 6 7
*/
/*题目思路
用单调队列的思想，如输出最小值时，
入队前将比当前数字大的从队尾出队，输出结果时输出队头，维护一个长度1<=队列长度<=滑动窗口得队列。*/
#include <iostream>//三步
using namespace std;
const int N = 1e6 + 10;
int hh = 0, tt = -1, n, k, a[N], q[N];//a数组存数字,q数组是单调队列存下标
int main() {
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n; i++)
        scanf("%d",&a[i]);//先存完再进行滑动窗口操作
    for(int i = 0; i < n; i ++ ) {
    //判断队列非空  hh <= tt
    //1.队首是否滑出滑动窗口
    //滑动窗口下标大于对首下标则说明队首滑出滑动窗口，需剔除队首
        if(hh <= tt && i - k + 1 > q[hh])  hh++;
    //先求最小值
    //2.为了保持单调队列的单调性，需在队尾进行删除操作。如：数组为 3 5 ,新进入的滑动窗口
    //数字为4，若在队首进行删除，那么3<4,那么就不用进行删除操作。数组就为3 5 4
    //不满足单调情况。而在队尾进行删除操作，因为5>4，3<4，所以5被删除，留下数组3 4
    //具有单调性
        while(hh <= tt && a[i] <= a[q[tt]])  tt--;
        q[ ++ tt] = i;//一定要在前两步操作后与下一步操作前存入
    //3.必须在滑动窗口有三个元素时输出。若滑动窗口内只有两个元素，则不输出
        if(i >= k - 1)    printf("%d ", a[q[hh]]);//对头为最小元素
    }
    puts("");//换行符
    //求最大值同理
    hh = 0, tt = -1;//hh tt值在求最小值时改变了，需得重新初始化
     for(int i = 0; i < n; i ++) {
        if(hh <= tt && i - k + 1 > q[hh])  hh ++;
        while(hh <= tt && a[i] >= a[q[tt]])  tt --;
        q[ ++ tt] = i;
        if(i >= k - 1)    printf("%d ", a[q[hh]]);
    }
    return 0;
}
```

### kmp算法（克努特-莫里斯-普拉特操作）

- kmp整体思路

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230223211934094.png" style="zoom:40%;" />

Next[i]=j是指，模板串中以i为终点的长度为j的这段和模板串1，j的部分是相等的，即p[1,j]=p[i-j+1,i]

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230224064403434.png" style="zoom:40%;" />

移动的时候，其实就是找以这个点（竖着的那条绿色的线）为终点的后缀和前缀相等的时候（将模板串p往后移）

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230224190233338.png" style="zoom:40%;" />

模式串S和模板串P的匹配过程是清楚了，但是Next数组的求取过程还没不能够很清楚明了的知道求解过程。

##### Kmp算法模板

```cpp
void getNext(vector<int>& next, string x){
        //i:后缀尾位置，j:前缀尾位置（也是长度）
        int j = 0;
        //初始化next数组
        next.push_back(0);
        
        for(int i = 1; i < x.length(); i++){
            while(j > 0 && x[i] != x[j] ) j = next[j - 1]; //处理不同情况
            if(x[i] == x[j]) j++; //处理相同情况
            next.push_back(j); //更新next数组
        }
    }
    int strStr(string text, string son) {
        //i:文本串位置，j:子串位置
        vector<int> next;
        getNext(next, son);
        int j = 0; 
        for(int i = 0; i < text.size(); i++){
            while(j > 0 && text[i] != sonson[j]) j = next[j - 1]; //处理不同情况
            if(text[i] ==son[j]) j++; //处理相同情况
            ... //根据题目要求操作
        }
        return -1;
    }
```

问题：在文本串中找子串

例子：在aabaabaaf中找aabaaf

遍历子串得到next数组（最大相等前后缀长度）

文本串中寻找子串存在的位置

根据next数组更新位置

**next数组情况分析：**

| 0    | 1    | 0    | 1    | 2    | 0    | 最大相等前后缀长度 | j = next[j - 1] |
| ---- | ---- | ---- | ---- | ---- | ---- | ------------------ | --------------- |
| -1   | 0    | 1    | 0    | 1    | 2    | 右移一位           | j = next[j]     |
| -1   | 0    | -1   | 0    | 1    | -1   | 每个位置-1         | j = next[j] + 1 |

[从头到尾彻底理解KMP（2014年8月22日版）_结构之法 算法之道-CSDN博客_kmp](https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request%5Fid%22%3A%22163774099916780265432000%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=163774099916780265432000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-7041827.pc_search_es_clickV2&utm_term=kmp&spm=1018.2226.3001.4187)

1、p[ ]是模板串，即比较短的字符串。
2、s[ ]是模式串，即比较长的字符串。
3、“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。
4、“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。
5、“部分匹配值”：前缀和后缀的最长共有元素的长度。
6、next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。
KMP核心思路：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次有可能匹配成功的位置,即next[j]，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。
next数组的含义：next[j]的含义是指模板串p[1,next[j]]与p[j-next[j]+1,j]完全相等，下面以字符串p = "abcab"为例求next数组

| p      | a    | b    | c    | a    | b    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 下标   | 1    | 2    | 3    | 4    | 5    |
| next[] | 0    | 0    | 0    | 1    | 2    |

对next[ 1 ] ：前缀 = 空集—————后缀 = 空集—————next[ 1 ] = 0;
对next[ 2 ] ：前缀 = { a }—————后缀 = { b }—————next[ 2 ] = 0;
对next[ 3 ] ：前缀 = { a , ab }—————后缀 = { c , bc}—————next[ 3 ] = 0;
对next[ 4 ] ：前缀 = { a , ab , abc }—————后缀 = { a . ca , bca }—————next[ 4 ] = 1;
对next[ 5 ] ：前缀 = { a , ab , abc , abca }————后缀 = { b , ab , cab , bcab}————next[ 5 ] = 2;
s[a,b] = p[1,j] && s[i] != p[j + 1]此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）
其中1串为[ 1, next[ j ] ]，3串为[j-next[j]+1,j]。由匹配可知 1串等于3串，3串等于2串。所以直接移动p串使1到3的位置即可。这个操作可由j = next[j]直接完成。 如此往复下去，当j == m时匹配成功。

##### ACWING:831

暴力算法

```cpp
/*831.Kmp字符串暴力匹配算法
假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？
    如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：
如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；
如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。
    暴力匹配的代码，如下：*/
int ViolentMatch(char* s, char* p)
{
	int sLen = strlen(s);
	int pLen = strlen(p);
 
	int i = 0;
	int j = 0;
	while (i < sLen && j < pLen)
	{
		if (s[i] == p[j])
		{
			//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    
			i++;
			j++;
		}
		else
		{
			//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    
			i = i - j + 1;
			j = 0;
		}
	}
	//匹配成功，返回模式串p在文本串s中的位置，否则返回-1
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

Kmp算法

```cpp
/*831.Kmp字符串
给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模板串P在模式串S中多次作为子串出现。
求出模板串P在模式串S中所有出现的位置的起始下标。
输入格式
第一行输入整数N，表示字符串P的长度。
第二行输入字符串P。
第三行输入整数M，表示字符串S的长度。
第四行输入字符串M。
输出格式:共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。
数据范围:1≤N≤10^4    1≤M≤10^5
输入样例：
3
aba
5
ababa
输出样例：
0 2*/
#include <iostream>
using namespace std;
const int N = 10010, M = 100010;
int n, m;
int ne[N];
char s[M], p[N];
int main() {
    cin >> n >> p+1 >> m >> s+1;        	//下标从1开始
    for(int i = 2, j = 0; i <= n; i++) { 	//i = 1时next数组为0
        while(j && p[i] != p[j+1]) j = ne[j];
        if(p[i] == p[j+1]) j++;
        ne[i] = j;    
    }
    for(int i = 1, j = 0; i <= m; i++) {
        while(j && s[i] != p[j+1]) j = ne[j];
        //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
        if(s[i] == p[j+1]) j++;//当前元素匹配，j移向p串下一位
        if(j == n) {			//匹配成功，进行相关操作
            cout << i-n << ' ';
            j = ne[j];      //找到完全匹配的字符串后重新从p的ne[n]位置开始搜索
        }
    }
}
```



**Day17.(2023.2.24)**

### Trie树（字典树）

- 快速存储和查找字符串集合的数据结构
- 按照每个字符串顺序进行建树，标记字符串结尾的地方/标记出现次数

![image](https://segmentfault.com/img/remote/1460000039216219)

字符串集合是{in, inn, int, tea, ten, to}

##### Tire树模板：

```cpp
//每个点存的是数字
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

##### ACWING:835

```cpp
/*835.Tire字符串统计
维护一个字符串集合，支持两种操作：
I x 向集合中插入一个字符串 x；
Q x 询问一个字符串在集合中出现了多少次。
共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。
输入格式
第一行包含整数 N，表示操作数。
接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。
输出格式
对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。
每个结果占一行。
数据范围
1≤N≤2∗10^4
输入样例：
5
I abc
Q abc
Q ab
I ab
Q ab
输出样例：
1
0
1*/
#include <iostream>
#include <cstring>
using namespace std;
const int N = 100010;
int cnt[N];//存储以下标为结尾的字符串的出现的次数
int son[N][26];//至多有N个字符，即N个结点，每个结点至多有26个子节点
int idx = 0;//用于标识节点的索引，初始值为0，根结点的idx为空
/**
    Trie树,字典树，用于存储和快速查找字符串，一般字符串内容是纯大写字母或者纯小写字母或者数字
**/
//将某个字符串插入到字典树中
void insertStr(char str[]) {
    int p = 0;//根节点的索引
    for(int i = 0; str[i]; i++) {
        int next_idx = str[i] - 'a';//求下一个字符所在的结点的索引
        if(!son[p][next_idx]) son[p][next_idx] = ++idx;//如果下一个字符str[i]不存在,则创建该字符对应的结点，标识idx自增。根节点或者尾节点的idx为0
        p = son[p][next_idx];//更新下一个字符所在节点的索引
    }
    cnt[p]++;//以下标为p结尾的某个字符串
}
int query(char str[]) {
    int p = 0;
    for(int i= 0; str[i]; i++) {
        int next_idx = str[i] - 'a';//求下一个字符所在的结点的索引
        if(!son[p][next_idx]) return 0;//如果当前字符不存在，则直接返回
        p = son[p][next_idx];//更新下一个字符所在节点的索引
    }
    return cnt[p];//返回以p标识的结点为结尾的字符串 出现的次数
}
int main() {
    int n;
    cin >> n;
    while( n -- ) {
        char op[2], str[N];
        scanf("%s%s", op, str);
        if(op[0] == 'I')  insertStr(str);
        else cout << query(str) << endl;
    }
    return 0;
}
```

变型题：

##### ACWING:143

```cpp
```



### 并查集（近乎O(1)）

1. 功能：

   - 将两个集合合并
   - 询问两个元素是否在一个集合当中

2. 基本原理

   - 每个集合用一颗树来表示，树根编号就是整个集合的编号，每个节点存储他的父节点（p[x]）

3. 操作

   - 问题1：如何判断树根：if(p[x] == x)
   - 问题2：如何求x的集合编号：while(p[x] != x) x = p[x]
   - 问题3：如何合并两个集合，p[x]是x的集合编号，p[y]是y的集合编号，p[x] = y

4. 优化

   - 查一次之后直接指向祖先（路径压缩）

     <img src="https://segmentfault.com/img/remote/1460000039216220" style="zoom:50%;" />

   <img src="https://segmentfault.com/img/remote/1460000039216216" style="zoom:50%;" />

   - 路径压缩：

   <img src="https://segmentfault.com/img/remote/1460000039216218" style="zoom:50%;" />
   <img src="https://segmentfault.com/img/remote/1460000039216217" style="zoom:50%;" />

5. 统计一个集合中数的数量（size[i]）

   - 合并集合：if(b的根节点 != a的根节点) size[b的根节点] += size[a的根节点]

```cpp
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);


(2)统计每个集合有多少个元素的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```

##### ACWING:836

```cpp
/*836.合并集合
一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
现在要进行 m 个操作，操作共有两种：
M a b，将编号为 aa 和 bb 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
Q a b，询问编号为 aa 和 bb 的两个数是否在同一个集合中；
输入格式
第一行输入整数 n 和 m。
接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。
输出格式
对于每个询问指令 Q a b，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1≤n, m≤105
输入样例：
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
输出样例：
Yes
No
Yes
*/
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int p[N]; // 当前节点的父节点；
// 该函数的含义：查找a所在集合的祖先节点下标，从1开始, 并内部更新p[a]为a节点的祖先节点。
int find(int a) {
    // 根据通项公式，假设p[a]的祖先节点已知。
    if (p[a] != a) p[a] = find(p[a]);
    return p[a];
}
int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    // 初始化每个集合
    for (int i = 1; i <= n; i++) p[i] = i;
    int a, b;
    char op[2];
    while (m -- ) {
        scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'M') p[find(a)] = find(b);
        else {
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

优化

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1e5 + 10;
string s;
int p[N], n, m, x, y;
int find(int x) {//查找集合与路径压缩
    if(p[x] != x) return p[x] = find(p[x]);
    return x;
}
int main() {
    scanf("%d%d", &n,  &m);
    for(int i = 1; i <= n; ++i)  p[i] = i;
    while(m -- ) {
        cin >> s;
        scanf("%d%d", &x, &y);
        if(s == "M") p[find(x)] = find(y); //一定要用父节点合并这样才能保证根节点唯一
        else printf("%s\n", find(x) == find(y) ? "Yes":"No");
    }
    return 0;
}
```



