# AcWing 算法基础课学习记录（C/C++，备战蓝桥杯）Day1 - Day30

备战蓝桥杯学习路线：acwing算法基础课->acwing蓝桥杯课->算法竞赛进阶指南

从今天开始系统性的学习算法，由于基础课和蓝桥课一共有85小时，现在每天平均是30mins到45mins，可能不是很够。从明天开始，每天看视频讲解一小时并且要消化内容，估计一起得花3-4小时。这样子差不多二月底，三月初可以结束视频课程）

**Day1**.(2023.2.8)

学习思路：1 先理解算法主要思想，2 背模板，3多做几道题（在做题的时候，当你AC了，马上把代码删除，再重新写一边，重复两三次）

**快速排序**

其主要思想是分治

1. 确定分界点de，一般选择左端点q[l]，右端点q[r]或者中间q[(l+r)/2]

2. 调整范围，将左边调整为小于等于分界点，右边调整为大于等于分界点

   ![快排](%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230209131103794.png)

3. 递归处理左右两段

   其中重难点是2，简单方法（但耗空间）是：

   1. 先设置两个数组a[], b[]

   2. 数组q[l~r]中小于等于de的放入a[]，大于等于de的放入b[]

   3. 然后将a和b合并放入数组q，a在左边，b在右边

主要方法是，在数组两端分别设置指针i,j，**while q[i]<de: i++，while q[j]>de: j--，if i<j swap(q[i],q[j]) else 递归处理左边部分(l,j)和右边部分(j+1,r)**。重复上述步骤。

C/C++模板：

```C++
/*快排模板（以j为分界）
快排属于分治算法，分治算法都有三步：1、分成子问题 2、递归处理子问题 3、子问题合并
快速排序的算法思想
（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
（2）治理：对两个子序列进行快速排序
（3）合并：将排序好的两个子序列合并在一起，得到原问题的解
分解是一个需要考虑的问题，如果基准元素选取不当，会造成两个子序列的规模分别为0和n-1，这样快速排序就退化成冒泡排序了。最理想的状态是把序列分解成两个规模相当的子序列。
对基准元素的选取一般有以下几种方法
1、取第一个元素 2、取最后一个元素 3、取中间位置的元素 4、取第一个元素、最后一个元素、中间位置的元素三者的中位数 5、取第一个元素和最后一个元素之间位置的随机数k（low≤k≤high),选R[k]作为基准元素。*/
//快排代码模板（acwing）
void quick_sort(int q[], int l, int r){
    //递归的终止情况
    if (l >= r) return;//if (l == r) return;
    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//等同于x = q[(l + r + 1) / 2] 注意边界问题：左i不能取左l，右j不能取右r
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //第二步：递归处理子问题
    quick_sort(q, l, j);//quick_sort(q, l, i-1)
    quick_sort(q, j + 1, r);//quick_sort(q, i, r)
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
void quick_sort(int a[], int l, int r) {
    if (l >= r) return ;

    int x = a[l + r >> 1], i = l, j = r;

    while (i <= j) {
        while(a[i] < x) i++;
        while(a[j] > x) j--;
        if (i <= j) swap(a[i++], a[j--]);
    }
    quick_sort(a, l, j);
    quick_sort(a, i, r);
}
```

ACWING:785

```C++
/*785.快速排序
给定你一个长度为 n 的整数数列。
请你使用快速排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 n。
第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。
输出格式
输出共一行，包含 n 个整数，表示排好序的数列。
数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5*/
#include <iostream>
using namespace std;
const int N = 1000010;
int q[N];
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) {
      scanf("%d", &q[i]);
    }
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i ++ ) {
      printf("%d ", q[i]);
    }
    return 0;
}
```

ACWING:786

```C++
/*786. 第k个数
给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列的第k小的数是多少。
输入格式
第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在1~109109范围内），表示整数数列。
输出格式
输出一个整数，表示数列的第k小数。
数据范围
1≤n≤1000001≤n≤100000,
1≤k≤n1≤k≤n
输入样例：
5 3
2 4 1 5 3
输出样例：
3
*/
/*使用快排模板
#include<iostream>
using namespace std;
 
const int N = 100010;
int n, k;
int q[N];
 
void quick_sort(int q[], int l, int r){
  if(l>=r) return;
  int x = q[(l+r)/2], i = l-1, j = r+1;
  while(i<j){
      do i++; while(q[i]<x);
      do j--; while(q[j]>x);
      if (i<j) swap(q[i],q[j]);
  }
  quick_sort(q,l,j);
  quick_sort(q,j+1,r); 
}
int main() {
  scanf("%d %d",&n,&k);
  for(int i=0;i<n;i++) {
    scanf("%d",&q[i]);
  }
  quick_sort(q,0,n-1);
  for(int i=0;i<n;i++)
	{   
		if (i==k-1) {
      printf("%d",q[i]);
    }
	}
	return 0;
}*/
/*1、找到分界点x，q[L],q[(L+R)/2],q[R]
2、左边所有数Left<=x，右边所有数Right>=x
3、递归排序Left，递归排序Right
  1、k<=Sl，递归Left
  2、k>Sl，递归Right，k-Sl
时间复杂度：n+n/2+n/4+...=N(1+1/2+1/4+...)<=2n*/
#include<iostream>
using namespace std;
const int N = 100010;
int n,k;
int q[N];
int quick_sort(int l, int r,int k){//C++全局变量和局部变量重名优先使用局部变量
  if(l >= r) {//区间内
    return q[(l + r)/2];
  }
  int x = q[(l + r)/2], i = l-1, j = r+1;
  while (i < j) {
    while(q[ ++ i] < x);
    while(q[ -- j] > x);
    if(i < j) {
      swap(q[i], q[j]);
    }
  }
  int s1 = j - l + 1;
  if (k <= s1) {
    return quick_sort(l, j, k);
  }
  else {
    return quick_sort(j + 1, r, k - s1);//return quick_sort(q,j+1,r,k-(j-l+1));
  }
}
int main(){
  int n,k;
  scanf("%d %d", &n, &k);
  for(int i = 0; i < n; i ++) {
    scanf("%d",&q[i]);
  }
  printf("%d",quick_sort(0, n - 1, k));
  return 0;
}
```



**Day2**.(2023.2.9)

**归并排序**

归并排序的主要思想也是分治，它和快排的思想不同，快排是边分边治，它是先分后治。

1. 确定分界点 mid=(r+l)/2

2. 递归排序左右两部分 （根据选出的分界点，将分界点左边的递归处理，右边的递归处理）

3. 归并-合二为一 （递归的终止条件是l>=r，返回后就要考虑怎么把左右两部分正确的合在一起）



**Day3**.(2023.2.10)

Day2的List五种生成方式和数据结构分析是今天做的。本来说把归并的788题做了，结果进去就跳转到算法基础课的活动，然后在leetcode上也没找到合适的题就把归并和快排复习了下，发现归并都是用<=或>=，而快排只有最开始判断的时候用了>=，其余都没有>=或<=，如果有的话还会报错。

**Day4**.(2021.10.11)

**二分**

这一节在刚开始听的时候还有点蒙蔽，一上来就在讲方法和思想，我连算法要解决的问题都还不清楚 。然后二分的本质不是单调性，而是边界。比如：给定一个区间，在这个区间中定义了某种性质，使得这个性质在有左半边区间是满足的，而右半部不满足（注意两者没有交点，当整数二分时），则二分就可以寻找到这个边界左半边的边界和右半的都可以找到。而找到左边的边界，和右边的边界就分别是用两个不同的模板了。

![二分](%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230209131155406.png)

这里解决的算法问题是假定先找黑色那个点，后找绿色那个点，然后整体思路就是：

找黑色的边界点，首先检查中间值是否满足黑色性质，

如果满足，则在mid右边部分找[mid,r], l=mid，注意是包含mid。否则mid左边找[l,mid-1],r=mid-1

找绿色的边界点，首先检查中间值是否满足绿色性质，

如果满足，则在mid的左边部分找[l,mid],r=mid。否则mid右边找[mid+1,r],l=mid+1

整数二分：

注意：在找右边边界时需要mid=(l+r+1)/2 （如果不加1，假设l=r-1，如果此时True会无限递归），左边是mid=(l+r)/2。

**模板**：解决单调数组找一个数最初和最后出现的位置，未出现则返回-1 -1

**Day5**.(2023.22.1)

说实话，二分算法的过程我感觉很抽象，必须要依靠画图才能肯定。

当你找左边界，是找所有>=num的数，如果arr[mid]>=num，那么答案一定在左半边，那么r=mid，因为也有可能就是mid。

![浮点二分](%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230209131233259.png)

假如红色点是左边界，现在mid在黄色点，是>=num（红色点的值）的，则应该去左边找，则令右边界为mid。

**浮点数二分：**

浮点数二分相对于整数二分就简单许多，不需要有加一减一等操作，只需要判断要找的数在mid左边还是右边。

ACWING:790