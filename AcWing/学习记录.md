备战蓝桥杯学习路线：acwing算法基础课->acwing蓝桥杯课->算法竞赛进阶指南

从今天开始系统性的学习算法，由于基础课和蓝桥课一共有85小时，现在每天平均是30mins到45mins，可能不是很够。从明天开始，每天看视频讲解一小时并且要消化内容，估计一起得花3-4小时。这样子差不多二月底，三月初可以结束视频课程）

**Day1**.(2023.2.8)

学习思路：1 先理解算法主要思想，2 背模板，3多做几道题（在做题的时候，当你AC了，马上把代码删除，再重新写一边，重复两三次）

**快速排序**

其主要思想是分治

1. 确定分界点de，一般选择左端点q[l]，右端点q[r]或者中间q[(l+r)/2]

2. 调整范围，将左边调整为小于等于分界点，右边调整为大于等于分界点

   ![](%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230209124143216.png)

3. 递归处理左右两段

   其中重难点是2，简单方法（但耗空间）是：

   1. 先设置两个数组a[], b[]

   2. 数组q[l~r]中小于等于de的放入a[]，大于等于de的放入b[]

   3. 然后将a和b合并放入数组q，a在左边，b在右边

主要方法是，在数组两端分别设置指针i,j，**while q[i]<de: i++，while q[j]>de: j--，if i<j swap(q[i],q[j]) else 递归处理左边部分(l,j)和右边部分(j+1,r)**。重复上述步骤。

C/C++模板：

```C++
/*快排模板（以j为分界）
快排属于分治算法，分治算法都有三步：1、分成子问题 2、递归处理子问题 3、子问题合并
快速排序的算法思想
（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
（2）治理：对两个子序列进行快速排序
（3）合并：将排序好的两个子序列合并在一起，得到原问题的解
分解是一个需要考虑的问题，如果基准元素选取不当，会造成两个子序列的规模分别为0和n-1，这样快速排序就退化成冒泡排序了。最理想的状态是把序列分解成两个规模相当的子序列。
对基准元素的选取一般有以下几种方法
1、取第一个元素 2、取最后一个元素 3、取中间位置的元素 4、取第一个元素、最后一个元素、中间位置的元素三者的中位数 5、取第一个元素和最后一个元素之间位置的随机数k（low≤k≤high),选R[k]作为基准元素。*/
//快排代码模板（acwing）
void quick_sort(int q[], int l, int r){
    //递归的终止情况
    if (l >= r) return;//if (l == r) return;
    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//等同于x = q[(l + r + 1) / 2] 注意边界问题：左i不能取左l，右j不能取右r
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //第二步：递归处理子问题
    quick_sort(q, l, j);//quick_sort(q, l, i-1)
    quick_sort(q, j + 1, r);//quick_sort(q, i, r)
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
void quick_sort(int a[], int l, int r) {
    if (l >= r) return ;

    int x = a[l + r >> 1], i = l, j = r;

    while (i <= j) {
        while(a[i] < x) i++;
        while(a[j] > x) j--;
        if (i <= j) swap(a[i++], a[j--]);
    }
    quick_sort(a, l, j);
    quick_sort(a, i, r);
}
```

**Day2**.(2023.2.9)

**归并排序**

归并排序的主要思想也是分治，它和快排的思想不同，快排是边分边治，它是先分后治。

1. 确定分界点 mid=(r+l)/2

2. 递归排序左右两部分 （根据选出的分界点，将分界点左边的递归处理，右边的递归处理）

3. 归并-合二为一 （递归的终止条件是l>=r，返回后就要考虑怎么把左右两部分正确的合在一起）



**Day3**.(2023.2.10)

Day2的List五种生成方式和数据结构分析是今天做的。本来说把归并的788题做了，结果进去就跳转到算法基础课的活动，然后在leetcode上也没找到合适的题就把归并和快排复习了下，发现归并都是用<=或>=，而快排只有最开始判断的时候用了>=，其余都没有>=或<=，如果有的话还会报错。

**Day4**.(2021.10.11)

**二分**

这一节在刚开始听的时候还有点蒙蔽，一上来就在讲方法和思想，我连算法要解决的问题都还不清楚 。然后二分的本质不是单调性，而是边界。比如：给定一个区间，在这个区间中定义了某种性质，使得这个性质在有左半边区间是满足的，而右半部不满足（注意两者没有交点，当整数二分时），则二分就可以寻找到这个边界左半边的边界和右半的都可以找到。而找到左边的边界，和右边的边界就分别是用两个不同的模板了。

这里解决的算法问题是假定先找黑色那个点，后找绿色那个点，然后整体思路就是：

找黑色的边界点，首先检查中间值是否满足黑色性质，

如果满足，则在mid右边部分找[mid,r], l=mid，注意是包含mid。否则mid左边找[l,mid-1],r=mid-1

找绿色的边界点，首先检查中间值是否满足绿色性质，

如果满足，则在mid的左边部分找[l,mid],r=mid。否则mid右边找[mid+1,r],l=mid+1

整数二分：

注意：在找右边边界时需要mid=(l+r+1)/2 （如果不加1，假设l=r-1，如果此时True会无限递归），左边是mid=(l+r)/2。

**模板**：解决单调数组找一个数最初和最后出现的位置，未出现则返回-1 -1

**Day5**.(2023.22.1)

说实话，二分算法的过程我感觉很抽象，必须要依靠画图才能肯定。

当你找左边界，是找所有>=num的数，如果arr[mid]>=num，那么答案一定在左半边，那么r=mid，因为也有可能就是mid。

假如红色点是左边界，现在mid在黄色点，是>=num（红色点的值）的，则应该去左边找，则令右边界为mid。

**浮点数二分：**

浮点数二分相对于整数二分就简单许多，不需要有加一减一等操作，只需要判断要找的数在mid左边还是右边。

ACWING:790