# AcWing 算法基础课学习记录（C/C++，备战蓝桥杯）Day1 - Day30

备战蓝桥杯学习路线：acwing算法基础课->acwing蓝桥杯课->算法竞赛进阶指南

从今天开始系统性的学习算法，由于基础课和蓝桥课一共有85小时，现在每天平均是30mins到45mins，可能不是很够。从明天开始，每天看视频讲解一小时并且要消化内容，估计一起得花3-4小时。这样子差不多二月底，三月初可以结束视频课程）

**Day1**.(2023.2.8)

学习思路：1 先理解算法主要思想，2 背模板，3多做几道题（在做题的时候，当你AC了，马上把代码删除，再重新写一边，重复两三次）

**快速排序**

其主要思想是分治

1. 确定分界点，一般选择左端点q[l]，右端点q[r]或者中间q[(l+r)/2]

2. 调整范围，将左边调整为小于等于分界点，右边调整为大于等于分界点

   ![快排](https://s2.loli.net/2023/02/10/qLHKPWzOMVxUpTb.png)

   对于第二步的调整区间，具体就是弄两个指针，分别指向数组的左右边界；不断的向中间遍历，将遍历过程中左边比x大的数和右边比x小的数交换，直到 i，j 相遇。

3. 递归处理左右两个区间，直到细分到不能细分

   其中重难点是2，简单方法（但耗空间）是：

   1. 先设置两个数组a[], b[]

   2. 数组q[l~r]中小于等于de的放入a[]，大于等于de的放入b[]

   3. 然后将a和b合并放入数组q，a在左边，b在右边

主要方法是，在数组两端分别设置指针i,j，**while q[i]<de: i++，while q[j]>de: j--，if i<j swap(q[i],q[j]) else 递归处理左边部分(l,j)和右边部分(j+1,r)**。重复上述步骤。

快排模板：

```C++
/*快排模板（以j为分界）
快排属于分治算法，分治算法都有三步：1、分成子问题 2、递归处理子问题 3、子问题合并
快速排序的算法思想
（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
（2）治理：对两个子序列进行快速排序
（3）合并：将排序好的两个子序列合并在一起，得到原问题的解
分解是一个需要考虑的问题，如果基准元素选取不当，会造成两个子序列的规模分别为0和n-1，这样快速排序就退化成冒泡排序了。最理想的状态是把序列分解成两个规模相当的子序列。
对基准元素的选取一般有以下几种方法
1、取第一个元素 2、取最后一个元素 3、取中间位置的元素 4、取第一个元素、最后一个元素、中间位置的元素三者的中位数 5、取第一个元素和最后一个元素之间位置的随机数k（low≤k≤high),选R[k]作为基准元素。*/
//快排代码模板（acwing）
void quick_sort(int q[], int l, int r){
    //递归的终止情况
    if (l >= r) return;//if (l == r) return;
    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//等同于x = q[(l + r + 1) / 2] 注意边界问题：左i不能取左l，右j不能取右r
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //第二步：递归处理子问题
    quick_sort(q, l, j);//quick_sort(q, l, i-1)
    quick_sort(q, j + 1, r);//quick_sort(q, i, r)
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
void quick_sort(int a[], int l, int r) {
    if (l >= r) return ;

    int x = a[l + r >> 1], i = l, j = r;

    while (i <= j) {
        while(a[i] < x) i++;
        while(a[j] > x) j--;
        if (i <= j) swap(a[i++], a[j--]);
    }
    quick_sort(a, l, j);
    quick_sort(a, i, r);
}
```

ACWING:785

```C++
/*785.快速排序
给定你一个长度为 n 的整数数列。
请你使用快速排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 n。
第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。
输出格式
输出共一行，包含 n 个整数，表示排好序的数列。
数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5*/
#include <iostream>
using namespace std;
const int N = 1000010;
int q[N];
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) {
      scanf("%d", &q[i]);
    }
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i ++ ) {
      printf("%d ", q[i]);
    }
    return 0;
}
```

ACWING:786

```C++
/*786. 第k个数
给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列的第k小的数是多少。
输入格式
第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在1~109109范围内），表示整数数列。
输出格式
输出一个整数，表示数列的第k小数。
数据范围
1≤n≤1000001≤n≤100000,
1≤k≤n1≤k≤n
输入样例：
5 3
2 4 1 5 3
输出样例：
3
*/
/*使用快排模板
#include<iostream>
using namespace std;
 
const int N = 100010;
int n, k;
int q[N];
 
void quick_sort(int q[], int l, int r){
  if(l>=r) return;
  int x = q[(l+r)/2], i = l-1, j = r+1;
  while(i<j){
      do i++; while(q[i]<x);
      do j--; while(q[j]>x);
      if (i<j) swap(q[i],q[j]);
  }
  quick_sort(q,l,j);
  quick_sort(q,j+1,r); 
}
int main() {
  scanf("%d %d",&n,&k);
  for(int i=0;i<n;i++) {
    scanf("%d",&q[i]);
  }
  quick_sort(q,0,n-1);
  for(int i=0;i<n;i++)
	{   
		if (i==k-1) {
      printf("%d",q[i]);
    }
	}
	return 0;
}*/
/*1、找到分界点x，q[L],q[(L+R)/2],q[R]
2、左边所有数Left<=x，右边所有数Right>=x
3、递归排序Left，递归排序Right
  1、k<=Sl，递归Left
  2、k>Sl，递归Right，k-Sl
时间复杂度：n+n/2+n/4+...=N(1+1/2+1/4+...)<=2n*/
#include<iostream>
using namespace std;
const int N = 100010;
int n,k;
int q[N];
int quick_sort(int l, int r,int k){//C++全局变量和局部变量重名优先使用局部变量
  if(l >= r) {//区间内
    return q[(l + r)/2];
  }
  int x = q[(l + r)/2], i = l-1, j = r+1;
  while (i < j) {
    while(q[ ++ i] < x);
    while(q[ -- j] > x);
    if(i < j) {
      swap(q[i], q[j]);
    }
  }
  int s1 = j - l + 1;
  if (k <= s1) {
    return quick_sort(l, j, k);
  }
  else {
    return quick_sort(j + 1, r, k - s1);//return quick_sort(q,j+1,r,k-(j-l+1));
  }
}
int main(){
  int n,k;
  scanf("%d %d", &n, &k);
  for(int i = 0; i < n; i ++) {
    scanf("%d",&q[i]);
  }
  printf("%d",quick_sort(0, n - 1, k));
  return 0;
}
```



**Day2**.(2023.2.9)

**归并排序**

归并排序的主要思想也是分治，它和快排的思想不同，快排是边分边治，它是先分后治。

1. 确定分界点 mid=(r+l)/2

2. 递归排序左右两部分 （根据选出的分界点，将分界点左边的递归处理，右边的递归处理）

3. 归并-合二为一 （递归的终止条件是l>=r，返回后就要考虑怎么把左右两部分正确的合在一起）

归并模板：

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

ACWING:787

```cpp
/*787.归并排序
给定你一个长度为l的整数数列。
请你使用归并排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 l。
第二行包含 l 个整数（所有整数均在1~10^9范围内），表示整个数列。
输出格式
输出共一行，包含l个整数，表示排好序的数列。
数据范围
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5
*/
/*算法实现
全分解，再排序合并
四步：
    取中位数，分解
    获取两区间起始点，对比合并于一个数组中
    扫尾
    将顺序数组按原数组起始存储至原数组中
*/
#include<iostream>
using namespace std;
// 设置可排序数量范围
const int N = 100010;
int n;
// 存放有序序列的临时数组
int q[N],tmp[N];
void merge_sort(int q[], int l, int r) {
  //边界的终止情况
  if (l >= r) {
    return;
  }
  //第一步：分成子问题
  int mid = l + r >> 1;
  //第二步：递归处理子问题
  merge_sort(q, l ,mid),merge_sort(q, mid+1, r);
  //第三步：合并子问题。设置k为存放有序序列的数组下标；i为待比较序列中第一个子序列的起始下标，j为待比较序列中第二个子序列的起始下标。
  int k = 0, i = l, j = mid + 1;
  while (i < mid && j <= r) {
    if(q[i] <= q[j]) {
      tmp[k ++ ] = q[i ++ ];
    } else {
      tmp[k ++ ] = q[j ++ ];
    }
  }
  // 比较完后，若第一个子序列还有剩余，将剩余的值添加到tmp中；第二个子序列剩余同理。
  while (i <= mid) {
    tmp[k ++ ] = q[i ++ ];
  }
  while (j <= r) {
    tmp[k ++ ] = q[j ++ ];
  }
  // 将有序序列存放至原数组中，相当于完成一轮合并
  for (k = 0, i = l; i <= r; k++, i ++) {
    q[i] = tmp [k];
  }
}
int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; i ++){
    scanf("%d", &q[i]);
  }
  merge_sort(q, 0, n-1);
  for (int i = 0; i < n; i ++) {
    printf("%d ",q[i]);
  }
  return 0;
}
```

ACWING:788

```cpp
/*788.逆序对的数量
给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。
逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。
输入格式
第一行包含整数 n，表示数列的长度。
第二行包含 n 个整数，表示整个数列。
输出格式
输出一个整数，表示逆序对的个数
数据范围
1≤n≤100000
数列中的元素的取值范围 [1,]。
输入样例
6
2 3 4 5 6 1
输入样例
5*/
/*解题思路：
假设一个函数merge_sort已经能求出逆序对的数量，若将这组数平分为左右两个部分，则逆序对的数量=左侧数内部逆序对的数量+右侧数内部逆序对的数量+右侧每个数与左侧数组成的逆序对数量的和。
1.把数组分成某个位置分成两个数组
2.对两边递归排序并计算出在同一边逆序对的数量
3.归并数组，并计算不在同一边的逆序对的数量
4.然后遍历看看有没有没归并的数
5.然后赋值给原数组*/
#include<iostream>
using namespace std;
 
const int N = 100010;
 
int n;
int q[N],tem[N];
 
long long merge_sort(int q[],int l,int r){// int 在1e5 时会爆
    if(l >= r) return 0;
    
    int mid = (l + r) >> 1;
    //递归左右两边逆序数对
    long long res = merge_sort(q,l,mid) + merge_sort(q,mid + 1,r);
    
    //归并并计算不在一边的逆序数对
    int k = 0,i = l,j = mid + 1;
    while(i <= mid && j <= r)
        if(q[i] <= q[j]) tem[k++] = q[i++];
        else {
            tem[k++] = q[j++];
            res += mid - i + 1;//计算逆序对数    
            //j的初始值为mid+1，此时当前的q[j]只与(q[k]，i<=k<j)这几个元素存在逆序关系；
            //归并排序从mid 的中间往两侧归并，因此中间元素是相对于当前mid有序的；    
        }
    //扫尾
    while (i <= mid) tem[k++] = q[i++];
    while (j <= r) tem[k++] = q[j++];
    
    //赋给原数组
    for (int i = l,j = 0; i <= r; i ++ ,j++)
        q[i] = tem[j];
        
        return res;
}
 
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    printf("%ld",merge_sort(q,0,n - 1));
    
    return 0;
}
```



**Day3**.(2023.2.10)

Day2的List五种生成方式和数据结构分析是今天做的。本来说把归并的788题做了，结果进去就跳转到算法基础课的活动，然后在leetcode上也没找到合适的题就把归并和快排复习了下，发现归并都是用<=或>=，而快排只有最开始判断的时候用了>=，其余都没有>=或<=，如果有的话还会报错。

**二分**

这一节在刚开始听的时候还有点蒙蔽，一上来就在讲方法和思想，我连算法要解决的问题都还不清楚 。然后二分的本质不是单调性，而是边界。比如：给定一个区间，在这个区间中定义了某种性质，使得这个性质在有左半边区间是满足的，而右半部不满足（注意两者没有交点，当整数二分时），则二分就可以寻找到这个边界左半边的边界和右半的都可以找到。而找到左边的边界，和右边的边界就分别是用两个不同的模板了。

![二分](https://s2.loli.net/2023/02/10/piJbPwmfCTN6QVO.png)

这里解决的算法问题是假定先找黑色那个点，后找绿色那个点，然后整体思路就是：

找黑色的边界点，首先检查中间值是否满足黑色性质，

如果满足，则在mid右边部分找[mid,r], l=mid，注意是包含mid。否则mid左边找[l,mid-1],r=mid-1

找绿色的边界点，首先检查中间值是否满足绿色性质，

如果满足，则在mid的左边部分找[l,mid],r=mid。否则mid右边找[mid+1,r],l=mid+1

整数二分：

注意：在找右边边界时需要mid=(l+r+1)/2 （如果不加1，假设l=r-1，如果此时True会无限递归），左边是mid=(l+r)/2。

**模板**：解决单调数组找一个数最初和最后出现的位置，未出现则返回-1 -1

说实话，二分算法的过程我感觉很抽象，必须要依靠画图才能肯定。

当你找左边界，是找所有>=num的数，如果arr[mid]>=num，那么答案一定在左半边，那么r=mid，因为也有可能就是mid。

![浮点二分](https://s2.loli.net/2023/02/10/iVycQvhpebPW9RD.png)

假如红色点是左边界，现在mid在黄色点，是>=num（红色点的值）的，则应该去左边找，则令右边界为mid。

整数二分模板（两种）：

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

ACWING:789

```cpp
/*789. 数的范围
给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。
对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。
如果数组中不存在该元素，则返回 -1 -1。
输入格式
第一行包含整数 n 和 q，表示数组长度和询问个数。
第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。
接下来 q 行，每行包含一个整数 k，表示一个询问元素。
输出格式
共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回 -1 -1。
数据范围
1≤n≤100000
1≤q≤10000
1≤k≤10000
输入样例：
6 3
1 2 2 3 3 4
3
4
5
输出样例：
3 4
5 5
-1 -1
*/
/*二分法，但是不是找其中的值，而是找到这个元素的边界。因为时升序数组，故我们找left时找第一个大于等于x的数的index，right时找最后一个小于等于x的数的index
上述都是从左向右看*/
#include <iostream>
using namespace std;
const int N = 100010;
int n, m;
int q[N];
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    while (m -- )
    {
        int x;
        scanf("%d", &x);
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if (q[l] != x) cout << "-1 -1" << endl;//l是边界，如果和x不等就是没有这个值
        else
        {
            cout << l << ' ';
            int l = 0, r = n - 1;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (q[mid] <= x) l = mid;
                else r = mid - 1;
            }
            cout << l << endl;
        }
    }
    return 0;
}
```

**浮点数二分：**

浮点数二分相对于整数二分就简单许多，不需要有加一减一等操作，只需要判断要找的数在mid左边还是右边。

浮点数二分区间长度足够小：看成一个数（**注意精度问题：**防止误差出现-->增加精度）

```cpp
#include<iostream>
using namespace std;
int main() {
  double x;
  cin >> x;
  double l = 0, r = x;
  //不用精度表示（精度足够小就停止）
  //for (int i = 0; i < 100; i ++)开一百次方（极小）
  while (r - l >1e-8) {//保留四位小数-1e-6 永远多2 一直做
    double  mid = (l + r) / 2;//每次求中点
    if (mid * mid >= x) r = mid;
    else l = mid;
  }
  printf("%lf\n",l);
  return 0;
}
```

ACWING:790

```cpp
```

