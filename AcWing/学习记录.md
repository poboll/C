# AcWing 算法基础课学习记录（C/C++，备战蓝桥杯）Day1 - Day30

备战蓝桥杯学习路线：acwing算法基础课->acwing蓝桥杯课->算法竞赛进阶指南

从今天开始系统性的学习算法，由于基础课和蓝桥课一共有85小时，现在每天平均是30mins到45mins，可能不是很够。从明天开始，每天看视频讲解一小时并且要消化内容，估计一起得花3-4小时。这样子差不多二月底，三月初可以结束视频课程）

**Day1**.(2023.2.8)

学习思路：1 先理解算法主要思想，2 背模板，3多做几道题（在做题的时候，当你AC了，马上把代码删除，再重新写一边，重复两三次）

## 基础算法

### 排序

#### 快速排序（nlogn） 分治

1. 判断退出条件

2. 确定分界点，一般选择左端点q[l]，右端点q[r]或者中间q[(l+r)/2]

3. 调整范围，将左边调整为小于等于分界点，右边调整为大于等于分界点

   ![快排](https://s2.loli.net/2023/02/10/qLHKPWzOMVxUpTb.png)

   对于第二步的调整区间，具体就是弄两个指针，分别指向数组的左右边界；不断的向中间遍历，将遍历过程中左边比x大的数和右边比x小的数交换，直到 i，j 相遇。

4. 递归处理左右两个区间，直到细分到不能细分

   其中重难点是2，简单方法（但耗空间）是：

   1. 先设置两个数组a[], b[]

   2. 数组q[l~r]中小于等于de的放入a[]，大于等于de的放入b[]

   3. 然后将a和b合并放入数组q，a在左边，b在右边

主要方法是，在数组两端分别设置指针i,j，**while q[i]<de: i++，while q[j]>de: j--，if i<j swap(q[i],q[j]) else 递归处理左边部分(l,j)和右边部分(j+1,r)**。重复上述步骤。

（边界问题，mid和递归的划分要对应，取不到出错）

##### 快排模板：

```C++
/*快排模板（以j为分界）
快排属于分治算法，分治算法都有三步：1、分成子问题 2、递归处理子问题 3、子问题合并
快速排序的算法思想
（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
（2）治理：对两个子序列进行快速排序
（3）合并：将排序好的两个子序列合并在一起，得到原问题的解
分解是一个需要考虑的问题，如果基准元素选取不当，会造成两个子序列的规模分别为0和n-1，这样快速排序就退化成冒泡排序了。最理想的状态是把序列分解成两个规模相当的子序列。
对基准元素的选取一般有以下几种方法
1、取第一个元素 2、取最后一个元素 3、取中间位置的元素 4、取第一个元素、最后一个元素、中间位置的元素三者的中位数 5、取第一个元素和最后一个元素之间位置的随机数k（low≤k≤high),选R[k]作为基准元素。*/
//快排代码模板（acwing）
void quick_sort(int q[], int l, int r){
    //递归的终止情况
    if (l >= r) return;//if (l == r) return;
    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];//等同于x = q[(l + r + 1) / 2] 注意边界问题：左i不能取左l，右j不能取右r
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    //第二步：递归处理子问题
    quick_sort(q, l, j);//quick_sort(q, l, i-1)
    quick_sort(q, j + 1, r);//quick_sort(q, i, r)
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
void quick_sort(int a[], int l, int r) {
    if (l >= r) return ;

    int x = a[l + r >> 1], i = l, j = r;

    while (i <= j) {
        while(a[i] < x) i++;
        while(a[j] > x) j--;
        if (i <= j) swap(a[i++], a[j--]);
    }
    quick_sort(a, l, j);
    quick_sort(a, i, r);
}
```

##### ACWING:785

```C++
/*785.快速排序
给定你一个长度为 n 的整数数列。
请你使用快速排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 n。
第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。
输出格式
输出共一行，包含 n 个整数，表示排好序的数列。
数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5*/
#include <iostream>
using namespace std;
const int N = 1000010;
int q[N];
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) {
      scanf("%d", &q[i]);
    }
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i ++ ) {
      printf("%d ", q[i]);
    }
    return 0;
}
```

##### ACWING:786

```C++
/*786. 第k个数
给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列的第k小的数是多少。
输入格式
第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在1~109109范围内），表示整数数列。
输出格式
输出一个整数，表示数列的第k小数。
数据范围
1≤n≤1000001≤n≤100000,
1≤k≤n1≤k≤n
输入样例：
5 3
2 4 1 5 3
输出样例：
3
*/
/*
1.找到分界点x，q[l]，q[(L + R)]，q[R]
2.左边所有数Left <= x，右边所有数Right >= x
3.递归排序Left，递归排序Right
	1、k <= Sl，递归Left
	2、k > Sl，递归Right，是第k-Sl个数
快选只用递归一边*/
/*使用快排模板
#include<iostream>
using namespace std;
 
const int N = 100010;
int n, k;
int q[N];
 
void quick_sort(int q[], int l, int r){
  if(l>=r) return;
  int x = q[(l+r)/2], i = l-1, j = r+1;
  while(i<j){
      do i++; while(q[i]<x);
      do j--; while(q[j]>x);
      if (i<j) swap(q[i],q[j]);
  }
  quick_sort(q,l,j);
  quick_sort(q,j+1,r); 
}
int main() {
  scanf("%d %d",&n,&k);
  for(int i=0;i<n;i++) {
    scanf("%d",&q[i]);
  }
  quick_sort(q,0,n-1);
  for(int i=0;i<n;i++)
	{   
		if (i==k-1) {
      printf("%d",q[i]);
    }
	}
	return 0;
}*/
/*1、找到分界点x，q[L],q[(L+R)/2],q[R]
2、左边所有数Left<=x，右边所有数Right>=x
3、递归排序Left，递归排序Right
  1、k<=Sl，递归Left
  2、k>Sl，递归Right，k-Sl
时间复杂度：n+n/2+n/4+...=N(1+1/2+1/4+...)<=2n*/
#include <iostream>
using namespace std;
const int N = 100010;
int n,k;
int q[N];
int quick_sort(int l, int r,int k){//C++全局变量和局部变量重名优先使用局部变量
    if(l >= r) {//区间内
        return q[(l + r)/2];
    }
    int x = q[(l + r)/2], i = l-1, j = r+1;
    while (i < j) {
        while(q[ ++ i] < x);
        while(q[ -- j] > x);
        if(i < j) {
          swap(q[i], q[j]);
        }
    }
    int s1 = j - l + 1;
    if (k <= s1) {
        return quick_sort(l, j, k);
    }
    else {
        return quick_sort(j + 1, r, k - s1);//return quick_sort(q,j+1,r,k-(j-l+1));
    }
}
int main(){
  int n,k;
  scanf("%d %d", &n, &k);
  for(int i = 0; i < n; i ++) {
      scanf("%d",&q[i]);
  }
  printf("%d",quick_sort(0, n - 1, k));
  return 0;
}
```



**Day2**.(2023.2.9)

#### 归并排序（nlogn） 分治

归并排序的主要思想也是分治，它和快排的思想不同，快排是边分边治，它是先分后治。

1. 判断退出条件

2. 确定分界点 mid=(r+l)/2

3. 递归排序左右两部分 （根据选出的分界点，将分界点左边的递归处理，右边的递归处理）

4. 归并-合二为一 （递归的终止条件是l>=r，返回后就要考虑怎么把左右两部分正确的合在一起）放到temp中

5. 存回原数组中


##### 归并模板：

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

##### ACWING:787

```cpp
/*787.归并排序
给定你一个长度为l的整数数列。
请你使用归并排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。
输入格式
输入共两行，第一行包含整数 l。
第二行包含 l 个整数（所有整数均在1~10^9范围内），表示整个数列。
输出格式
输出共一行，包含l个整数，表示排好序的数列。
数据范围
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5
*/
/*算法实现
全分解，再排序合并
四步：
    取中位数，分解
    获取两区间起始点，对比合并于一个数组中
    扫尾
    将顺序数组按原数组起始存储至原数组中
*/
#include <iostream>
using namespace std;
// 设置可排序数量范围
const int N = 100010;
int n;
// 存放有序序列的临时数组
int q[N],tmp[N];
void merge_sort(int q[], int l, int r) {
    //边界的终止情况
    if (l >= r) {
        return;
    }
    //第一步：分成子问题
    int mid = l + r >> 1;
    //第二步：递归处理子问题
    merge_sort(q, l ,mid),merge_sort(q, mid+1, r);
    //第三步：合并子问题。设置k为存放有序序列的数组下标；i为待比较序列中第一个子序列的起始下标，j为待比较序列中第二个子序列的起始下标。
    int k = 0, i = l, j = mid + 1;
    while (i < mid && j <= r) {
        if(q[i] <= q[j]) {
            tmp[k ++ ] = q[i ++ ];
        } else {
            tmp[k ++ ] = q[j ++ ];
        }
  }
  // 比较完后，若第一个子序列还有剩余，将剩余的值添加到tmp中；第二个子序列剩余同理。
    while (i <= mid) {
        tmp[k ++ ] = q[i ++ ];
    }
    while (j <= r) {
        tmp[k ++ ] = q[j ++ ];
    }
    // 将有序序列存放至原数组中，相当于完成一轮合并
    for (k = 0, i = l; i <= r; k++, i ++) {
        q[i] = tmp [k];
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i ++){
        scanf("%d", &q[i]);
    }
    merge_sort(q, 0, n-1);
    for (int i = 0; i < n; i ++) {
        printf("%d ",q[i]);
    }
    return 0;
}
```

##### ACWING:788

逆序对是用归并的思想（分治）做的，只求逆序对中大的在左边序列，小的在右边序列的情况（最开始划分区间划分到为1的时候会解决大的和小的在一边的情况）。然后怎样计算有多少个逆序对呢：mid-i+1，当a[i]都比a[j]大的时候，左边序列i后面的值肯定也都比a[j]大。

```cpp
/*788.逆序对的数量
给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。
逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。
输入格式
第一行包含整数 n，表示数列的长度。
第二行包含 n 个整数，表示整个数列。
输出格式
输出一个整数，表示逆序对的个数
数据范围
1≤n≤100000
数列中的元素的取值范围 [1,]。
输入样例
6
2 3 4 5 6 1
输入样例
5*/
/*解题思路：
假设一个函数merge_sort已经能求出逆序对的数量，若将这组数平分为左右两个部分，则逆序对的数量=左侧数内部逆序对的数量+右侧数内部逆序对的数量+右侧每个数与左侧数组成的逆序对数量的和。
1.把数组分成某个位置分成两个数组[L, R] => [L, mid],[mid + 1, R]
2.对两边递归排序并计算出在同一边逆序对的数量 递归排序[L, mid]和[mid + 1, R]
3.归并数组，并计算不在同一边的逆序对的数量 归并，将左右梁国有序序列合并成一个有序序列
4.然后遍历看看有没有没归并的数
5.然后赋值给原数组
	1.左半边内部的逆序对数量：merge_sort(L, mid)
	2.右半边内部的逆序对数量：merge_sort(mid + 1, R)
	3.归并，将左右两个有序序列合并成一个有序序列
*/
#include<iostream>
using namespace std;
const int N = 100010;
int n;
int q[N],tem[N];
long long merge_sort(int q[],int l,int r){// int 在1e5 时会爆
    if(l >= r) return 0;
    int mid = (l + r) >> 1;
    //递归左右两边逆序数对
    long long res = merge_sort(q,l,mid) + merge_sort(q,mid + 1,r);
    
    //归并并计算不在一边的逆序数对
    int k = 0,i = l,j = mid + 1;
    while(i <= mid && j <= r)
        if(q[i] <= q[j]) tem[k++] = q[i++];
        else {
            tem[k++] = q[j++];
            res += mid - i + 1;//计算逆序对数    
            //j的初始值为mid+1，此时当前的q[j]只与(q[k]，i<=k<j)这几个元素存在逆序关系；
            //归并排序从mid 的中间往两侧归并，因此中间元素是相对于当前mid有序的；    
        }
    //扫尾
    while (i <= mid) tem[k++] = q[i++];
    while (j <= r) tem[k++] = q[j++];
    
    //赋给原数组
    for (int i = l,j = 0; i <= r; i ++ ,j++)
        q[i] = tem[j];
        
        return res;
}
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    printf("%ld",merge_sort(q,0,n - 1));
    
    return 0;
}
```

#### C++的sort()

快速排序+插入排序



**Day3**.(2023.2.10)

Day2的List五种生成方式和数据结构分析是今天做的。本来说把归并的788题做了，结果进去就跳转到算法基础课的活动，然后在leetcode上也没找到合适的题就把归并和快排复习了下，发现归并都是用<=或>=，而快排只有最开始判断的时候用了>=，其余都没有>=或<=，如果有的话还会报错。

### 二分

这一节在刚开始听的时候还有点蒙蔽，一上来就在讲方法和思想，我连算法要解决的问题都还不清楚 。然后二分的本质不是单调性，而是边界。比如：给定一个区间，在这个区间中定义了某种性质，使得这个性质在有左半边区间是满足的，而右半部不满足（注意两者没有交点，当整数二分时），则二分就可以寻找到这个边界左半边的边界和右半的都可以找到。而找到左边的边界，和右边的边界就分别是用两个不同的模板了。

![二分](https://s2.loli.net/2023/02/10/piJbPwmfCTN6QVO.png)

这里解决的算法问题是假定先找黑色那个点，后找绿色那个点，然后整体思路就是：

找黑色的边界点，首先检查中间值是否满足黑色性质，

如果满足，则在mid右边部分找[mid,r], l=mid，注意是包含mid。否则mid左边找[l,mid-1],r=mid-1

找绿色的边界点，首先检查中间值是否满足绿色性质，

如果满足，则在mid的左边部分找[l,mid],r=mid。否则mid右边找[mid+1,r],l=mid+1

整数二分：

注意：在找右边边界时需要mid=(l+r+1)/2 （如果不加1，假设l=r-1，如果此时True会无限递归），左边是mid=(l+r)/2。

**模板**：解决单调数组找一个数最初和最后出现的位置，未出现则返回-1 -1

说实话，二分算法的过程我感觉很抽象，必须要依靠画图才能肯定。

当你找左边界，是找所有>=num的数，如果arr[mid]>=num，那么答案一定在左半边，那么r=mid，因为也有可能就是mid。

![浮点二分](https://s2.loli.net/2023/02/10/iVycQvhpebPW9RD.png)

假如红色点是左边界，现在mid在黄色点，是>=num（红色点的值）的，则应该去左边找，则令右边界为mid。

#### 整数二分

二分保证一定有解，题目不一定有解

1. 写while
2. 取mid = (l + r) / 2
3. 写check函数
4. 看check函数决定l = mid还是r = mid(l=mid时候第一步+1)

##### 整数二分模板（两种）：

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

##### ACWING:789

```cpp
/*789. 数的范围
给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。
对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。
如果数组中不存在该元素，则返回 -1 -1。
输入格式
第一行包含整数 n 和 q，表示数组长度和询问个数。
第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。
接下来 q 行，每行包含一个整数 k，表示一个询问元素。
输出格式
共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回 -1 -1。
数据范围
1≤n≤100000
1≤q≤10000
1≤k≤10000
输入样例：
6 3
1 2 2 3 3 4
3
4
5
输出样例：
3 4
5 5
-1 -1
*/
/*二分法，但是不是找其中的值，而是找到这个元素的边界。因为时升序数组，故我们找left时找第一个大于等于x的数的index，right时找最后一个小于等于x的数的index
上述都是从左向右看*/
#include <iostream>
using namespace std;
const int N = 100010;
int n, m;
int q[N];
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    while (m -- )
    {
        int x;
        scanf("%d", &x);
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if (q[l] != x) cout << "-1 -1" << endl;//l是边界，如果和x不等就是没有这个值
        else
        {
            cout << l << ' ';
            int l = 0, r = n - 1;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (q[mid] <= x) l = mid;
                else r = mid - 1;
            }
            cout << l << endl;
        }
    }
    return 0;
}
```

##### ACWING:790

```cpp
/*790.数的三次方根
给定一个浮点数 n，求它的三次方根。
输入格式
共一行，包含一个浮点数 n。
输出格式
共一行，包含一个浮点数，表示问题的解。
注意，结果保留 6 位小数。
数据范围
−10000≤n≤10000
输入样例：
1000.00
输出样例：
10.000000
*/
/*思路
浮点数的二分，在0~n间一直二分直到精度<1e-9停止*/
#include <iostream>
using namespace std;
int main() {
    double a;
    cin >> a;
    if(a < 0) {
        cout << '-';
        a = a * (-1);
    }
    double l = 0, r = a;
    while(r - l > 1e-8) { //绝对值是否大于一个很小的数值0.00000001
        double mid = (l + r) / 2;
        if(mid * mid * mid >= a) r = mid;
        else l = mid;
    }
    printf("%lf", l);
    return 0;
}
```



#### 浮点数二分：

> eg: 找平方根

浮点数二分相对于整数二分就简单许多，不需要有加一减一等操作，只需要判断要找的数在mid左边还是右边。

浮点数二分区间长度足够小：看成一个数（**注意精度问题：**防止误差出现-->增加精度）

- 保留四位小数 精度 < 1e-6
- 五位小数 1e-7
- 六位小数 1e-8

```cpp
/*浮点数二分*/
#include<iostream>
using namespace std;
int main() {
    double x;
    cin >> x;
    double l = 0, r = x;
    //不用精度表示（精度足够小就停止）
    //for (int i = 0; i < 100; i ++)开一百次方-->极小
    while (r - l >1e-8) {//保留四位小数-1e-6 永远多2 一直做
        double  mid = (l + r) / 2;//每次求中点
        if (mid * mid >= x) r = mid;
        else l = mid;
    }
    printf("%lf\n",l);
    return 0;
}
```



**Day4**.(2023.2.11)

##### ACWING:790

```cpp
```

### 高精度

- 大整数存储：用字符串读，用vector存（小端）

Java和Python不需要关注高精度，Java有大整数类，Python本身就是无限大。但万一以后搞C++去了呢？

大数运算一般有A+B, A-B, A*a, A/a。其中大写代表大数（位数在1000000之内），小写代表小数（值效于10000）。解决这几个问题一般是模拟人工加法的过程：

当然首先要看的是怎么存储两个大数，要用数组来存储，而且是数组的低位存大数的低位，假如123456789为大数，则arr[0]=9, arr[1]=8 ... arr[8]=1。这是因为高位可能要进位，这样进位后不需要移动数组。

#### 高精度加法 A+B 10^6

1. 算每一位的和放到vector中
2. 当前位 %10，进位 /10
3. 最后要处理是否还有进位

##### 高精度加法模板：

```cpp
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

##### ACWING:791

```cpp
/*791.高精度加法
给定两个正整数（不含前导0），计算它们的和。
输入格式
共两行，每行包含一个整数。
输出格式
共一行，包含所求的和。
数据范围
1≤整数长度≤100000
输入样例：
12
23
输出样例：
35
*/
/*vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果你用.at()访问的话，也可以做越界检查。
v.push_back(t)  //在数组的最后添加一个值为t的数据
v.size()   //当前使用数据的大小
v.pop_back();  // 弹出容器中最后一个元素（容器必须非空）
v.back();   // 返回容器中最后一个元素的引用
*/
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e6 +10;
// C = A + B
vector<int> add(vector<int> &A, vector<int> &B) {//C++11新特性  添加引用-->提高效率
    vector<int> C;//定义数组C存两数之和
    int t = 0;//上一位的进位
    for (int i = 0; i < A.size() || B.size(); i ++) {
        if (i < A.size()) t += A[i];//按位做加法
        if (i < B.size()) t += B[i];//B的高位全加进去
        C.push_back(t % 10);//t存储该位a，b和模10即为结果
        t /= 10;//t存储进位为0或1
    }
    if (t) C.push_back(1);//最高位进位1
    return C;
}
int main() {
    string a, b;//定义字符串a，b
    vector<int> A, B;//定义数组A,B
    cin >> a >> b; //输入两个数a，b    a = "123456"
    for (int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0');// A = [6, 5, 4, 3, 2, 1]  把字符串中字符变为整型数字并逆序存入数组
    for (int i = b.size() - 1; i >= 0; i --) B.push_back(b[i] - '0');
    auto C = add(A , B);//调用函数，返回和存入数组C。auto编译器自己推断类型等价于 vector<int> C
    for (int i = C.size() - 1; i >= 0; i --) printf("%d", C[i]);//遍历输出C中元素即为两数和
    return 0;
}
```

#### vector

vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果用.at()访问的话，也可以做越界检查。

```cpp
v.push_back(t)  //在数组的最后添加一个值为t的数据
v.size()   //当前使用数据的大小
v.pop_back();  // 弹出容器中最后一个元素（容器必须非空）
v.back();   // 返回容器中最后一个元素的引用
```

#### 高精度减法 A-B 10^6 （）

1. 先比较位数，然后从最高位开始比较。A>=B，否则算-(B-A)
2. 循环处理每一位（判断B的位数是否还能减），记录是否有借位
3. 处理前导0

##### 高精度减法模板：

```cpp
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

##### ACWING:792

```cpp
/*792.高精度减法
给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。
输入格式
共两行，每行包含一个整数。
输出格式
共一行，包含所求的差。
数据范围
1≤整数长度≤10^5
输入样例：
32
11
输出样例：
21
*/
/*vector是一种顺序容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而vector正好弥补了这个缺陷，它的特征是相当于可分配拓展的数组，它的随机访问快，在中间插入和删除慢，但在末端插入和删除快，而且如果用.at()访问的话，也可以做越界检查。
v.push_back(t)  //在数组的最后添加一个值为t的数据
v.size()   //当前使用数据的大小
v.pop_back();  // 弹出容器中最后一个元素（容器必须非空）
v.back();   // 返回容器中最后一个元素的引用
*/
#include <iostream>
#include <vector>
using namespace std;
//判断是否有 A >=B
bool cmp(vector<int> &A, vector<int> &B) {//判断A,B大小关系
    if (A.size() != B.size()) return A.size() > B.size();//直接ruturn 了就不用else
    for (int i = A.size() - 1; i >= 0; i --) {
        if(A[i] != B[i]) {
            return A[i] > B[i];//逐位看A和B哪个数较大
        }
    }
    return true;//所有都相等返回true
}
// C = A + B
vector<int> sub(vector<int> &A, vector<int> &B) {//C++11新特性  添加引用-->提高效率
    vector<int> C;
    for(int i = 0, t = 0; i < A.size(); i ++ ) {
        t = A[i] - t;//t表示进位
        if (i < B.size()) t -= B[i];//判断B是否还存在
        C.push_back((t + 10) % 10);
        // 若t>=0,则返回t，若小于0则表示借位需+10，合并即为(t + 10) % 10 )
        if (t < 0) t = 1;
        else t = 0;
    }
    while (C.size() > 1 && C.back() == 0) {
        C.pop_back();//去掉前导0，如果c=0则不能去掉该0；
    }
    return C;
}
int main() {
    string a, b;//定义字符串a，b
    vector<int> A, B;//定义数组A,B
    cin >> a >> b; //输入两个数a，b    a = "123456"
    for (int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0');// A = [6, 5, 4, 3, 2, 1]  把字符串中字符变为整型数字并逆序存入数组
    for (int i = b.size() - 1; i >= 0; i --) B.push_back(b[i] - '0');
    if (cmp(A, B)) {
        auto C = sub(A , B);//调用函数，返回和存入数组C。auto编译器自己推断类型等价于 vector<int> C
        for (int i = C.size() - 1; i >= 0; i --) printf("%d", C[i]);//遍历输出C中元素即为两数差
    } else {//当A<B时计算B-A在前边添加负号即可
        auto C = sub(B, A);
        printf("-");
        for(int i = C.size() - 1; i >= 0; i --) {
          printf("%d",C[i]);
        }
    }
    return 0;
}
```

#### 高精度乘低精度 A*a len(A) <= 10^6 a <= 10^9

1. A的每一位乘a
2. 当前位为(A *a + 进位) % 10，进位为（A* a + 进位）/ 10
3. 不要忘记处理最后的进位

##### 高精度乘低精度模板：

```cpp
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

##### ACWING:793

```cpp
/*793.高精度乘法
给定两个非负整数（不含前导 0） A 和B ，请你计算 A × B 的值。
输入格式
共两行，第一行包含整数 A ，第二行包含整数B 。
输出格式
共一行，包含 A × B 的值。
数据范围
1 ≤ A 的长度 ≤ 100000 , 1≤A的长度≤100000,1≤A的长度≤100000,
0 ≤ B ≤ 10000 0≤B≤100000≤B≤10000
输入样例：
2
3
输出样例：
6*/
/*本题名为高精度乘法，实为高精度整数与普通整数相乘，而并非两个高精度整数相乘，故难度有所降低。
类似于高精度加法，本题从低位至高位将高精度整数每一位乘以普通整数。每次计算得到的结果由几部分相加构成：从低位来的进位、本位相乘结果
得到的结果又分为个位和高位两个部分：个位直接存进结果中，作为乘积结果中对应位的值；高位则继续保留，留至后面的位计算时处理。
如此循环往复，当高精度整数每一位均处理完后，将高精度整数最高位计算的进位一并存入结果中。
最后筛除前导0，得出乘积结果。若理解有困难，自行模拟乘法过程即可。*/
#include <iostream>
#include <string>
#include <vector>
using namespace std;
vector<int> mul(vector<int> a, int b) {
    vector<int> c;
    int num = 0; //用来存放临时计算结果
    for (int i = 0; i < a.size() || num != 0; i ++ )
    {
        if (i < a.size()) num += a[i] * b;
        c.push_back(num % 10);
        num /= 10;
    }
    //筛除前导0
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}

int main() {
    string A;
    int b;
    cin >> A >> b;
    //用vector存储高精度整数
    vector<int> a, c;
    for (int i = A.size() - 1; i >= 0; i -- ) a.push_back(A[i] - '0');
    //进行乘法过程
    c = mul(a, b);
    //输出乘法结果
    for (int i = c.size() - 1; i >= 0; i -- ) cout << c[i];
    return 0;
}
```

力扣 题b范围太大无法通过

#### 高精度除以低精度 A/B

- 从最高位开始算
- 余数为余数乘10 + 当前位
- 当前结果为 余数/b
- 余数为 当前余数%b
- 去除前导0

##### 高精度除以低精度模板：

```cpp
/*794.高精度除法
给定两个非负整数（不含前导 00） A，BA，B，请你计算 A/BA/B 的商和余数。
输入格式
共两行，第一行包含整数 AA，第二行包含整数 BB。
输出格式
共两行，第一行输出所求的商，第二行输出所求余数。
数据范围
1≤A的长度≤1000001≤A的长度≤100000,
1≤B≤100001≤B≤10000,
BB 一定不为 00
输入样例：
7
2
输出样例：
3
1
*/
/*思路
按照除法的法则
设置余数r
r一开始初始化为0
由于除法是从高位开始计算的 所以结果也是从高位开始存储的（结果需要反转）
r = r * 10 + Ai
商就是r / 10
反而余数r = r % 10 对于下一个A[i]进行计算*/
#include <iostream>
#include <algorithm>
using namespace std;
//A/b   商是c，余数r
vector<int> div(vector<int> &A,int b, int &r)//r是引用
{
    vector<int> C; //商是C，用vector<int>型存储商
    r =0;//r控制每次计算的余数
    for(int i =A.size()-1; i>=0; i--)//除法运算过程
    {
        r= r* 10+A[i];//余数*10+下一位作为下次被除数
        C.push_back(r/b);//输出商
        r %=b;//计算r下一次运算的值
    }
    reverse(C.begin(),C.end());
    while(C.size()>1 && C.back() ==0) C.pop_back();
    //去掉前导0当商为1时不去除即C.size()>1
    return C;
}
int main()
{
    string a;//高精度数a存为字符串
    int b;//较小数b
    cin >>a >> b;//输入两数
    vector<int> A;//定义数组A
    for(int i =a.size() -1; i>=0; i--) 
        A.push_back(a[i]-'0');//在A数组中正序添加高精度数a
    int r;
    auto C = div(A,b,r);//调用函数计算商
    for(int i =C.size() -1;i>=0;i--) 
        printf("%d",C[i]);
    cout << endl << r <<endl;//输出余数r
    return 0;
}
```

##### ACWING:794

```cpp
/*794.高精度除法
给定两个非负整数（不含前导 00） A，BA，B，请你计算 A/BA/B 的商和余数。
输入格式
共两行，第一行包含整数 AA，第二行包含整数 BB。
输出格式
共两行，第一行输出所求的商，第二行输出所求余数。
数据范围
1≤A的长度≤1000001≤A的长度≤100000,
1≤B≤100001≤B≤10000,
BB 一定不为 00
输入样例：
7
2
输出样例：
3
1
*/
/*思路
按照除法的法则
设置余数r
r一开始初始化为0
由于除法是从高位开始计算的 所以结果也是从高位开始存储的（结果需要反转）
r = r * 10 + Ai
商就是r / 10
反而余数r = r % 10 对于下一个A[i]进行计算*/
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
//A/b   商是c，余数r
vector<int> div(vector<int> &A,int b, int &r)//r是引用
{
    vector<int> C; //商是C，用vector<int>型存储商
    r =0;//r控制每次计算的余数
    for(int i =A.size()-1; i>=0; i--)//除法运算过程
    {
        r= r* 10+A[i];//余数*10+下一位作为下次被除数
        C.push_back(r/b);//输出商
        r %=b;//计算r下一次运算的值
    }
    reverse(C.begin(),C.end());
    while(C.size()>1 && C.back() ==0) C.pop_back();
    //去掉前导0当商为1时不去除即C.size()>1
    return C;
}
int main()
{
    string a;//高精度数a存为字符串
    int b;//较小数b
    cin >>a >> b;//输入两数
    vector<int> A;//定义数组A
    for(int i =a.size() -1; i>=0; i--) 
        A.push_back(a[i]-'0');//在A数组中正序添加高精度数a
    int r;
    auto C = div(A,b,r);//调用函数计算商
    for(int i =C.size() -1;i>=0;i--) 
        printf("%d",C[i]);
    cout << endl << r <<endl;//输出余数r
    return 0;
}
```

### 前缀和（核心：求和）

**下标从1开始，好处理边界问题**

#### 一维前缀和

> 前缀和是指数组中前 i 项的和，通常用 sum i 表示。
> 我们设 a 是原数组：sum i = a1 + a2 +a3 + ... + ai。

- 如何求：Si = a1+a2+...+ai
- 作用:求出一段的和
  - [l,r] = Sr - Sl-1
- 定义：
  - S0 = 0
  - Si = Si-1 + ai

前缀和算法一般用来处理区间和问题。

<img src="https://cdn.acwing.com/media/article/image/2022/07/29/125398_40bb4fea0f-%E5%89%8D%E7%BC%80%E5%92%8C.png" style="zoom:40%;" />

##### 一维前缀和模板：

```cpp
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

首先做一个预处理，定义一个`sum[]`数组，`sum[i]`代表`a`数组中前`i`个数的和。

##### 求前缀和运算：

```cpp
const int N=1e5+10;
int sum[N],a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];
for(int i=1;i<=n;i++)
{  
    sum[i]=sum[i-1]+a[i];   
}
```

然后查询操作：

```cpp
scanf("%d%d",&l,&r); printf("%d\n", sum[r]-sum[l-1]);
```

对于每次查询，只需执行`sum[r]-sum[l-1]` ，时间复杂度为`O(1)`

**原理**

`sum[r] =a[1]+a[2]+a[3]+a[l-1]+a[l]+a[l+1]......a[r]`;
`sum[l-1]=a[1]+a[2]+a[3]+a[l-1]`;
`sum[r]-sum[l-1]=a[l]+a[l+1]+......+a[r]`;

这样，对于每个询问，`只需要执行 sum[r]-sum[l-1]`。输出原序列中从第`l`个数到第r个数的和的时间复杂度变成了`O(1)`。

ACWING:795

```cpp
/*795.前缀和
输入一个长度为 nn 的整数序列。
接下来再输入 mm 个询问，每个询问输入一对 l, r。
对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。
输入格式
第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数数列。
接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。
输出格式
共 m 行，每行输出一个询问的结果。
数据范围
1≤l≤r≤n,
1≤n,m≤100000
−1000≤数列中元素的值≤1000
输入样例：
5 3
2 1 3 6 4
1 2
1 3
2 4
输出样例：
3
6
10
*/
#include<iostream>
using namespace std;
const int N = 1e5+10;
int n, m;
int a[N], s[N];
int main() {
    scanf("%d%d", &n, &m);//大数据输入scanf快一倍
    for(int i = 1; i <= n; i ++) { 
        scanf("%d", &a[i]);
    }
    for(int i = 1; i <= n; i ++) {//前缀和的初始化
        s[i]=s[i - 1] + a[i];
    }
    while(m -- ) { 
        int l,r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]);//区间和的计算
    }
    return 0;
}
```

*ios*::sync_with_stdio(false);//提高cin读取速度，不能使用scanf

```cpp
#include<iostream>
using namespace std;
const int N=1e5+10;
int a[N],sum[N];
int main() {
    ios::sync_with_stdio(false);//提高cin读取速度，不能使用scanf
    int n,m,x;
    cin>>n>>m;
    for(int i=1;i<=n;i++) {
        cin>>x;
        sum[i]=x+sum[i-1];
    }
    while(m--) {
        int l,r;
        cin>>l>>r;
        cout<<sum[r]-sum[l-1]<<endl;
    }
    return 0;
}
```

#### 二维前缀和：

求二维前缀和

<img src="https://cdn.acwing.com/media/article/image/2022/08/04/125398_aaf29dba13-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png" style="zoom:50%;" />

- Sij：左上所有元素的和

```dts
S_ {ij} = S_ {(i-1)j} + S_ {i(j-1)} -  S_ {(i-1)(j-1)} +  a_ {ij}
```

求任意子矩阵和<img src="https://cdn.acwing.com/media/article/image/2022/08/04/125398_d448a74113-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C2.png" style="zoom:50%;" />

- (x1,y1)到(x2,y2)的所有元素和

```llvm
S_ {x1,y1->x2,y2} = S_ {x2,y2} + S_ {x2,y1-1} -  S_ {x1-1,y2} +  S_ {x1-1,y1-1}
```

##### 二维前缀和模板：

```cpp
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

类似于前缀和,见 ACWing 795. 前缀和（C++），即将其由一维扩展到二维。

二维前缀和的每项可由公式求得：

```cpp
s[i][j]=s[i−1][j]+s[i][j−1]−s[i−1][j−1]+a[i][j]
```

对于每次的询问操作，子矩阵之和 sum 同样可直接用公式求得：

```cpp
sum=s[x2][y2]−s[x1−1][y2]−s[x2][y1−1]+s[x1−1][y1−1]
```

将矩阵存储至二维数组中时下标从1开始，这样做有两点好处：

1. 使得在进行求子矩阵和的操作过程中行列数与数组中行列数完全对应；
2. 注意到求解过程中出现 x 1 − 1 , y 1 − 1 x1 - 1,y1 - 1x1−1,y1−1 等数，若是从 0 00 开始，则为避免数组越界（出现 s [ − 1 ] s[-1]s[−1] 等值）,对于这些情况需要重新讨论，增加了程序复杂程度。

##### ACWING:796

```cpp
/*796.子矩阵的和
输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。
对于每个询问输出子矩阵中所有数的和。
输入格式
第一行包含三个整数 n，m，q
接下来 n nn 行，每行包含 m mm 个整数，表示整数矩阵。
接下来 q qq 行，每行包含四个整数 x1, y1, x2, y2，表示一组询问。
输出格式
共 q 行，每行输出一个询问的结果。
数据范围
1 ≤ n , m ≤ 1000 , 
1 ≤ q ≤ 200000 ,
1 ≤ x 1 ≤ x 2 ≤ n ,
1 ≤ y 1 ≤ y 2 ≤ m ,
− 1000 ≤ 矩阵内元素的值 ≤ 1000
输入样例：
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
输出样例：
17
27
21
*/
#include<iostream>
using namespace std;
const int N=1010;
int n, m, q;
int a[N][N], s[N][N];
int main(void) {
    scanf("%d%d%d",&n,&m,&q);
    for(int i = 1; i <= n; i ++) {
        for(int j = 1;j <= m; j ++) {
            scanf("%d", &a[i][j]);
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; //求二维前缀和
        }
    }
    while( q-- ) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]); //求任意子矩阵和
    }
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;
const int N = 1010;
int n, m, q;
int a[N][N], sum[N][N];
int x, y, xx, yy;
int main() {
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i ++ ) {
        for (int j = 1; j <= m; j ++ ) {
            cin >> a[i][j];
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]; //求二维前缀和
        }
    }
    while (q -- ) {
        cin >> x >> y >> xx >> yy;
        cout << sum[xx][yy] - sum[x - 1][yy] - sum[xx][y - 1] + sum[x - 1][y - 1] << endl; //求任意子矩阵和
    }
    return 0;
}
```



### 差分（核心：构造子序列）前缀和的逆运算

#### 一维差分

应用：在一个数组a[]的指定区间[l,r]上每个数都加上c

- 构造出b[](b[i] = a[i] - a[i - 1])，a是b的前缀和
- 要a在[l,r]上的每个数都加c
- b[l] += c
- b[r+1] -=c
- 对b求前缀和，得到要的a

假定a: a1,a2,a3...,an是数组b: b1,b2,b3...,bn的前缀和数组，那么称b是a的差分数组。即ai = b1+b2+b3+...+bi。（反过来可以推出b1=a1,b2=a2-a1,b3=a3-a2...,bn=an-an-1）(差分其实就是前缀和的逆运算)

差分有什么用呢，首先可以在O(n)的时间内，由b数组得到a数组，**重点**：让数组a某段（l,r）每个元素都加上（连续加多次）某一值的操作从O(n)->O(1)，只需要将b[l]+c,b[r+1]-c。

首先我们要考虑如何初始化差分数组，然而对于差分数组来说，我们不需要单独考虑如何构造，只需要考虑如何更新（把初始化也当成更新）。

**重点**：我们来看下为什么可以把初始化也当成更新操作，首先你假设a数组全为0，则差分数组b也全为0。现在你要做的更新操作就是在数组a[1,1]，[2,2]，[3,3]...的范围依加上a1,a2,a3...，则相当于在数组b[1]+a1,b[2]-a1、b[2]+a2,b[3]-a2、...

##### 一维差分模板：

```cpp
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

差分就是前缀和的逆运算，我们可以将一个数组构建为差分数组a，使得其前缀和就是原始数组，如果我们要在区间[l ,r] 上加上某一个数c，其实我们就相当于我们在差分数组中对a[l] += c, a[r + 1] -= c。这样最后的时候求一遍前缀和就可以得出最后的数组了

##### ACWING:797

```cpp
/*797.差分
给定一个长n的整数序列A，再进行m次操作，每次操作包含三个整数l,r,c表示将序列中的[l,r]每个数都增c 。输出操作完后的数列。区间的下标是从1开始计数的。
输入格式：
第一行包含两个整数n和m。第二行包含n个整数，表示整数序列。接下来m行，每行包含三个整数l，r，c表示一个操作。
输出格式：
共一行，包含n个整数，表示最终序列。
数据范围：
1≤n,m≤100000
1 ≤ l ≤ r ≤ n
− 1000 ≤ c ≤ 1000 -1000
− 1000 ≤ A [ i ] ≤ 1000
样例输入：
输入：
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
输出：
3 4 5 3 4 2
*/
/*
思路是利用差分数组。求出差分数组d使得
A[i]=∑d[0:i]
真实代码中可以想象A一开始都是0，每次将A[i:i]增加一个数，而对于差分数组来说，原数组A[l:r]全体增加一个数c，效果是d[l]增加c，而d[r+1]减少c（如果r+1越界了那就忽略），这样方便编程。*/
#include <iostream>
using namespace std;
const int N = 100010;
int n, m;
int a[N],b[N];
void insert(int l, int r, int c){//插入函数
    b[l] += c;
    b[r + 1] -= c;
}
int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= n; i ++){
        insert(i, i, a[i]);
    }
    while (m --){
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        insert(l, r, c);
    }
    for (int i = 1; i <= n; i ++){
        b[i] += b[i - 1];
    }
    for (int i = 1; i <= n; i ++){
        printf("%d ", b[i]);
    }
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int a[N], d[N];
int n, m, l, r, c;
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) {
        d[i] += a[i]; 
        if (i + 1 < n)
            d[i + 1] -= a[i];
    }
    while (m--) {
        cin >> l >> r >> c;
        d[l - 1] += c;
        d[r] -= c;
    }
    int s = 0;
    for (int i = 0; i < n; i++) {
        s += d[i];
        printf("%d ", s);
    }
    return 0;
}
```

#### 二维差分

应用：对二维矩阵指定区间的所有值加上c

- 构造b[](bi = ai - ai - 1 - ai + ai - 1)
- 要a在[x1,y1]到[x2,y2]上的每个数都加c
- bi += c
- bi + 1 -= c
- bi -= c
- bi + 1 +=c

注意二维差分和二维前缀和的不同，二维前缀和是对给定点的左上角操作，而二维差分则是对右下角进行操作。如果记不清楚该加减的位置，可以画图，这样更直观准确。（这里可能不好理解初始化二维差分数组的操作，插入操作是指在原数组某一范围插入一个数而要改变差分数组的哪些值的操作，当你在模拟在原始数组的每个点插入相对应的数时（这个动作是在改变差分数组的值），就相当于初始化差分数组）

##### 二维差分模板：

```cpp
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

<img src="https://s2.loli.net/2023/02/11/u12RaJsjBmDQSbC.png" style="zoom: 40%;" />

其实这些数，都是在处理**二维前缀和的数+1**得到的

当对差分矩阵进行构造时，我们只需要对其每次的1x1小矩阵插入即可，原理和一维差分一致。当对差分矩阵进行多次子矩阵插入之后，可以通过**求二维前缀和**获得对应的矩阵。

##### ACWING:798

```cpp
/*输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中(x1,y1)和(x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上c。
请你将进行完所有操作后的矩阵输出。
输入格式
第一行包含整数n,m,q。
接下来n行，每行包含m个整数，表示整数矩阵。
接下来q行，每行包含5个整数x1,y1,x2,y2,c，表示一个操作。
输出格式
共n行，每行m个整数，表示所有操作进行完毕后的最终矩阵。
数据范围
1 ≤ n , m ≤ 1000 ,
1 ≤ q ≤ 100000 ,
1 ≤ x1 ≤ x2 ≤ n ,
1 ≤ y1 ≤ y2 ≤ m ,
− 1000 ≤ c≤ 1000 ,
− 1000 ≤ 矩阵内元素的值 ≤ 1000 
输入样例：
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
输出样例：
2 3 4 1
4 3 4 1
2 2 2 2
*/
#include <iostream>
using namespace std;
const int N = 1e3 + 10;//1010
int b[N][N];
int n, m, k;
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main() {
    scanf("%d%d%d", &n, &m, &k);
    // 初始化构造差分矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
              int x;
              scanf("%d", &x);
              insert(i, j, i, j, x);
          }
    }
    // 多次进行矩阵区域插入
    while (k--) {
        int x1, y1, x2, y2, c;
        scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &c);
        insert(x1, y1, x2, y2, c);
    }
    // 对差分矩阵求二维前缀和
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            printf("%d ", b[i][j]);
        }
        puts("");
    }
    return 0;
}
```



**Day5**.(2023.2.12)

### 双指针：

- 两个序列两个指针
- 一个序列首尾指针
- 核心思想：O（n ^ 2） -> O(n)
- i是左指针

双指针算法有两大类，第一大类是分别指向两个数组，第二大类是同时指向一个序列。

双指针算法一般都可以从暴力的角度着手（看下i和j有没有什么单调关系），从而将算法复杂度从o(n^2)降低到o(n)。

#### 双指针模板:

```cpp
for (int i = 0, j = 0; i < n; i ++ )//后指针不断更新
{
    while (j < i && check(i, j)) j ++ ;//不满足条件，前指针更新
    
    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

基本运用：

#### 输出单个字符

```cpp
#include <iostream>
#include <string.h>
using namespace std;
int main() {
    char str[1000];
    gets(str);
    int n = strlen(str);
    for (int i = 0; i < n; i ++) {
        int j = i;
        while(j < n && str[j] !=' ') j ++;
        //这道题的具体逻辑
        for (int k = i; k < j; k ++) cout << str[k];
        cout << endl;
        i = j;
    }
    return 0;
}
```

##### ACWING:799

朴素做法：双重循环，对区间 [ i , j ] 进行重复性检查。i 可以遍历所有的终点情况，j 结束循环是已找到对于终点 i 最远的起点，之后对所有终点情况取最小值即可。此做法时间复杂度为 O(n^2)。

```cpp
	//i是区间终点，j是区间起点
	for (int i = 0; i < n; i ++ ) {
		for (int j = 0; j <= i; j ++ ) {
			//check函数检查i, j之间有无重复数
			if (check(i, j) == 0) break;
		}
		res = min(res, i - j + 1);
	}
```

改进方法：双指针算法
注意到，随着 i 的增加，j 的值不可能减少。因为区间 [ j , i ] 已经出现重复元素，所以区间 [ p , q ] ( p < j , i < q ) 中也必然出现重复元素，故 j 的值无需每次循环都回溯到 0，而是在全过程中单调不减的。由此，可以使用如下的双指针算法：

```cpp
    for (int i = 0, j = 0; i < n; i ++ ) {
        s[a[i]] ++;
        while (s[a[i]] > 1) s[a[j ++]] --;
        res = max(res, i - j + 1);
    }
```

完整代码：

```cpp
/*799.最长连续不重复子序列
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
输入格式
第一行包含整数 n。
第二行包含 n 个整数（均在 0 ∼ 10^5 范围内），表示整数序列。
输出格式
共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围
1 ≤ n ≤ 10^5
输入样例：
5
1 2 2 3 5
输出样例：
3
*/
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], s[N]; //a[i]用来存放原序列,s[i]用来存放区间中各数字出现次数
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    int res = 0;
    for (int i = 0, j = 0; i < n; i ++ ) {
        s[a[i]] ++; //a[i]出现次数加1
        while (s[a[i]] > 1) s[a[j ++]] --; //起点右移，直至没有区间内没有重复
        res = max(res, i - j + 1);
    }
    cout << res << endl;
    return 0;
}
```



### 位运算：

位运算一般有两个作用：

1. n的二进制表示中第k位是几(n>>k&1)。

2. lowbit操作（这道题好像是返回最右边的1所代表的数，树状数组的一个基本操作）

   二进制数：最后一位1-->最后

   ​	x = 1010 lowbit(x) = 10

   ​	x = 101000				1000

   <img src="https://s2.loli.net/2023/02/12/IHXWTt87lnzONfC.png" style="zoom:40%;" />

   ```cpp
   #include <iostream>
   using namespace std;
   int main() {
       int n = 10;
       for(int k = 3; k >= 0; k --) cout << (n >> k & 1);
       return 0;
   }
   ```

   <img src="https://s2.loli.net/2023/02/12/AKotriHxdTO9zqY.png" alt="" style="zoom:40%;" />

   

   它的功能是可以统计x里面1的个数（每次都把最后一个1去掉，减了多少次就有多少个1）

   <img src="https://s2.loli.net/2023/02/12/XU6bHhPWoiZ93mS.png" style="zoom:40%;" />

```cpp
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n
```

#### 位运算-二进制表示：

- 先把第k位移到最后一位 n >> k
- 看个位是几 & 1
- n >> k & 1(相当于与000001)

```cpp
#include <iostream>
using namespace std;
int main() {
    int n = 10;
    for(int k = 3; k >= 0; k --) cout << (n >> k & 1);
    return 0;
}
```

#### lowbit(x)：

- eg：x = 101000 lowbit(x) = 1000
- lowbit(x)实现：x & -x
- 应用：统计1的个数
- eg：x -= lowbit(x) ans++;

##### ACWING:801

```cpp
/*给定一个长n的数列A，求每个数的二进制表示中1的个数。
输入格式：
第一行包含整数n。第二行包含n个整数，表示整个数列。
输出格式：
共一行，包含n个整数，其中的第i个数表示数列中的第i个数的二进制表示中1的个数。
数据范围：
1 ≤ n ≤ 100000
0 ≤ A [i] ≤ 10^90
可以用lowbit来做*/
#include <iostream>
using namespace std;
int lowbit(int x) {
    return x & -x;
}
int main() {
    int n;
    cin >> n;
    while (n --) {
        int x, cnt = 0;
        cin >> x;
        while (x) {// 直至删到 0 为止 
            x -= lowbit(x); // 进行更新操作在二进制表示中将最后一位 1 至最低位的部分删掉
            cnt ++;
        }
        cout << cnt << ' '; // 输出删除的次数，即二进制表示中 1 的个数
    }
    return 0;
}
```

下面解释下为什么在计算机中用补码表示负数（最后一步手工带入x算）：

<img src="https://s2.loli.net/2023/02/12/MP6HWhAZfTk4BNG.png" style="zoom:40%;" />





### 离散化：

> 这里特指整数离散化，而且是有序的离散化（它的值域跨度很大，但是很稀疏）

- 思想：将0~10^9的n个不连续值映射到0，1，2，3 ... n-1
- eg：1，20，50000 -> 0，1，2
- 应用：值的跨度大，真正用到的数很少（AcWing 802）
- 排序
- 去重 alls.erase(unique(alls.begin(), alls.end()), alls.end());
- unique()将重复元素放到后面，返回下标
- 二分查找对应离散化值

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230212203954537.png" style="zoom:40%;" />

#### 离散化模板：推荐使用C++STL库函数

```cpp
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

##### ACWING:802

```cpp
/*802.区间和
假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。
现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。
接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。
输入格式
第一行包含两个整数 n 和 m。
接下来 n 行，每行包含两个整数 x 和 c。
再接下来 m 行，每行包含两个整数 l 和 r。
输出格式
共 m 行，每行输出一个询问中所求的区间内数字和。
数据范围
−10^9 ≤ x ≤ 10^9,
1 ≤ n,m ≤ 10^5,
−10^9 ≤ l ≤ r ≤ 10^9,
−10000 ≤ c ≤ 10000
输入样例：
3 3
1 2
3 6
7 5
1 3
4 6
7 8
输出样例：
8
0
5
*/
//离散化
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int n,m;
const int N = 300010;
//设置一个离散数据连续化之后存储add操作数据的数组a[N]，以及其前缀和数组s[N]
int a[N],s[N];
//定义一个vector数组把所有题目中操作涉及到的下标存储进去
vector<int>alls;
//定义一个数对类型来表示每次的加c操作和询问
typedef pair<int,int> PII;
//设置一个vector数组来存储每次的加c操作和询问操作的数对（数对作为一个基本元素,vector数组是存储若干个这样的数对）
vector<PII>add, query;
//默写一下二分模板 待会要用
int find(int x) {
    int l = 0,r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;//也可以返回r r+1是将数据离散化成1,2,3,4...n(从1开始，而不是从0开始)
}
int main() {
    cin >> n >> m;
    //现在开始循环执行n次加c操作，初始化add和alls数组
    for (int i = 0; i < n; i ++) {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    //现在开始循环执行m次询问操作，初始化query和alls数组
    for (int i = 0; i < m; i ++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //然后我们开始对alls数组进行排序和去重
    //这里补充一下，alls数组存在的意义其实为了将下标排序，看每次的l和r之间有哪些x是在里面的
    //这些离散的x在连续化映射之后得到的值就会作为之后利用a[N]前缀和求和的下标依据
    sort(alls.begin(),alls.end());//排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());//去重。unique函数是ctl中自带的函数
    //现在我们开始处理并统计数轴中经过add操作之后不是0的那些部分
    //也就是初始化a数组，把原来数轴中不为0的那些位置上的数字统计过来
    //存储的下标x依据就是利用二分来寻找其在alls数组中的相对位置
    for (auto item:add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    //预处理前缀和，这一步是用来求最后[l,r]区间的依据
    for (int i = 1; i <= alls.size(); i ++) s[i] = s[i-1] + a[i];
    //处理询问
    for (auto item:query) {
        //item.first和item.second其实就是原来键盘中输入的每次询问的l和r
        //下面的l和r是经过映射之后的下标
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l-1] << endl;
    }
    return 0;
}
```

自行实现迭代器：

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int n,m;
const int N = 300010;
//设置一个离散数据连续化之后存储add操作数据的数组a[N]，以及其前缀和数组s[N]
int a[N],s[N];
//定义一个vector数组把所有题目中操作涉及到的下标存储进去
vector<int>alls;
//定义一个数对类型来表示每次的加c操作和询问
typedef pair<int,int> PII;
//设置一个vector数组来存储每次的加c操作和询问操作的数对（数对作为一个基本元素,vector数组是存储若干个这样的数对）
vector<PII>add, query;
//默写一下二分模板 待会要用
int find(int x) {
    int l = 0,r = alls.size() - 1;
    while (l<r) {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;//也可以返回r r+1是将数据离散化成1,2,3,4...n(从1开始，而不是从0开始)
}
vector<int>::iterator unique(vector<int> &a) {
    int j = 0;
    for (int i = 0; i < a.size(); i ++) {
        if(!i || a[i] != a[i - 1]) {
            a[j ++ ] = a[i];
        }
    }
    // a[0] ~ a[j - 1] 所有a中不重复的数
    return a.begin() + j;
}
int main() {
    cin >> n >> m;
    //现在开始循环执行n次加c操作，初始化add和alls数组
    for (int i = 0; i < n; i ++) {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    //现在开始循环执行m次询问操作，初始化query和alls数组
    for (int i = 0; i < m; i ++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //然后我们开始对alls数组进行排序和去重
    //这里补充一下，alls数组存在的意义其实为了将下标排序，看每次的l和r之间有哪些x是在里面的
    //这些离散的x在连续化映射之后得到的值就会作为之后利用a[N]前缀和求和的下标依据
    sort(alls.begin(),alls.end());//排序
    alls.erase(unique(alls),alls.end());//去重。unique函数是ctl中自带的函数
    //现在我们开始处理并统计数轴中经过add操作之后不是0的那些部分
    //也就是初始化a数组，把原来数轴中不为0的那些位置上的数字统计过来
    //存储的下标x依据就是利用二分来寻找其在alls数组中的相对位置
    for (auto item:add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    //预处理前缀和，这一步是用来求最后[l,r]区间的依据
    for (int i = 1; i <= alls.size(); i ++) s[i] = s[i-1]+a[i];
    //处理询问
    for (auto item:query) {
        //item.first和item.second其实就是原来键盘中输入的每次询问的l和r
        //下面的l和r是经过映射之后的下标
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l-1] << endl;
    }
    return 0;
}
```



**Day5**.(2023.2.12)

### 区间合并：

>快速把n个区间有交集的快速合并

- 按区间左端点排序
- 扫描整个区间，将有交集的区间合并
- 如果右端点小于当前左边，更新左右端点
- 如果右端点大于等于当前左边，更新右端点

```cpp
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

#### ACWING:803

>依据新区间和维护区间是否有相交的部分，可以将上述 3 种情况视为 2 种情形。
>如果新区间的左端点 > 维护区间的右端点，则两个区间没有相交部分，则将维护区间的左右端点保存起来；
>如果新区间的左端点 <= 维护区间的右端点，则两个区间有相交部分，则更新维护区间的右端点，取两个区间右端点的最大值。

Tips

- pair++ 中，会优先对左端点进行从小到大的排序，再对右端点进行从小到大的排序。
- 将 vector 容器作为函数参数，使用引用传递的方式，在形式参数前加上 &，函数内部形参发生变化时，这种改变可以直接传递给被调用的实参。
- 注意边界 -2e9

```cpp
/*803.区间合并
给定n个区间[l, r]。
合并所有有交集的区间。
输出合并完成后的区间个数。
例如：[1,3]和[2,6]可以合并为一个区间[1,6]。
输入格式
第一行包含整数n。
接下来n行，每行包含两个整数 l 和 r。
输出格式
共一行，包含一个整数，表示合并区间完成后的区间个数。
样例
输入样例：
5
1 2
2 4
5 6
7 8
7 9
输出样例：
3
*/
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
int n;
vector<PII> segs;
void merge(vector<PII> &segs) {
  vector<PII> res;
  sort(segs.begin(), segs.end());
  int st = -2e9, ed = -2e9;
  for (auto seg : segs) {
      if (ed < seg.first) {
          if (st != -2e9) res.push_back({st, ed});
          st = seg.first, ed = seg.second;
      }
      else ed = max(ed, seg.second);
  }
  if (st != -2e9) res.push_back({st,ed});
  segs = res;
}
int main() {
    cin >> n;
    for(int i = 0; i < n; i ++) {
        int l, r;
        cin >> l >> r;
        segs.push_back({l,r});
    }
    merge(segs);
    cout << segs.size() <<endl;
    return 0;
}
```



**Day13.(2023.2.20)**

## 数据结构

### 链表与邻链表

一般我们接触到的链表都是动态链表，如下图所示，但是动态链表的创建是非常满的（new操作），很大概率就直接超时了，所以一般只有面试的时候才用，笔试的时候不用。

```cpp
struct Node
{
    int val;
    Node *next
}

new Node(); //非常慢
```

这里讲的是拿数组模拟链表（单链表：用的最多的是邻接表，n个单链表合起来，用于存储树或者图，双链表：优化某些问题）

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230220224836262.png" style="zoom: 43%;" />

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230221230541531.png" alt="插入操作（非头节点）" style="zoom:43%;" />

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230221230637732.png" alt="删除操作" style="zoom:43%;" />

#### 数组模拟单链表 静态链表

##### 单链表模板

```csharp
int head; //头节点
int e[N]; //值
int ne[N]; //next指针
int idx; //数组用到第几个点

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert_head(int a)
{
    e[idx] = a;
    ne[idx] = head;
    head = idx;
    idx++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}

// 将a插入到第k个点后面
void add(int k, int a)
{
    e[idx] = a;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx ++;
}
//将下标是k的后边的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
```

**Day14.(2023.2.21)**

##### ACWING:826

```cpp
/*826.单链表
实现一个单链表，链表初始为空，支持三种操作：
向链表头插入一个数；
删除第 k个插入的数后面的数；
在第 k个插入的数后插入一个数。
现在要对该链表进行 M次操作，进行完所有操作后，从头到尾输出整个链表。
注意:题目中第 k个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
输入格式
第一行包含整数 M，表示操作次数。
接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：
    H x，表示向链表头插入一个数 x。
    D k，表示删除第 k个插入的数后面的数（当 k 为 0时，表示删除头结点）。
    I k x，表示在第 k个插入的数后面插入一个数 x（此操作中 k 均大于 0）。
输出格式
共一行，将整个链表从头到尾输出。
数据范围
1≤M≤100000
所有操作保证合法。
输入样例：
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
输出样例：
6 4 6 5
*/
/*基本思想：
①将一个数x插到现有头结点之前
②将一个数x插到下标为k的数的后面一位
③删除一个节点
思路
用 a 数组代表数据域 ，然后 ne 数存储的是指针域。
创建一个链表即创建一个头指针，head = -1；
然后存储的数据个数是 idx 初始化即为 0 ；
插入操作即将第 k 和数据后面插入一个 x : 首先创建节点 a[idx] = x ; 然后将指针指向k后面的节点 ne[idx] = ne[k] ;
k 的指针再指向新的节点 ne[k] = idx ++ (加一是因为这样就不用再写一个idx++);
删除操作，因为是静态链表，不需要释放资源，直接将的要删除的数的前一个指针指向后一个，ne[k] = ne[ne[k]];
如果是头指针即 head = ne[haed];
头插：类似于插入只是将 j 换成了head ,创建节点： a[idx] = x;
指针指向头指针指向的数据ne[idx] = head ,头指针指向head = idx++;*/
#include<iostream>
using namespace std;
const int N = 100010;
//单链表
// head 头指针,描述第一个结点的索引,-1表示单链表结尾，初始化时链表为空，所有head指向tail=-1
// e[i] 表示节点i的值
// ne[i] 表示节点i的next指针是多少
// idx 存储当前已经用到了哪个点
int head, e[N], ne[N], idx;
// 初始化
void init() {
    head = -1;
    idx = 0;//一开始位0
}
/**
 * 功能：向链表头插入一个数
 * @param x
 */
void add_to_head(int x) {
    /*四步法
     1、存值
     2、将头指针指向的结点标识为下一个结点
     3、将头指针指向当前结点
     4、idx++准备下一个可用的索引号
    */
    e[idx] = x, ne[idx] = head, head = idx++;
}
/**
 * 功能：将x插到下标是k的点后面
 * @param k
 * @param x
 */
void add(int k, int x) {
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;
}
/**
 * 功能：将下标是k的点后面的点删掉
 * 比如想删除第k个结点，那么需要传入k-1,因为k-1的下一个结点才是k
 * @param k
 */
void remove(int k) {
    ne[k] = ne[ne[k]];
}
int main() {
    //优化输入
    ios::sync_with_stdio(false);
    //m次操作
    int m;
    cin >> m;
    init();//初始化
    while (m--) {
        int k, x;
        char op;
        cin >> op;
        //头插法:x
        if (op == 'H') {
            cin >> x;
            add_to_head(x);
        } else if (op == 'D') {
            //表示删除第k个插入的数后面的数（当k为0时，示删除头结点）。
            cin >> k;
            //删除头结点需要特判，否则会丢失关系
            if (k == 0) head = ne[head];//或if (!k) 
            //第k个插入的数，那么在数组中下标是k-1,所以调用时需要使用remove(k-1,x)
            else remove(k - 1);
        } else {
            //在第k个插入的数后插入一个数
            cin >> k >> x;
            //第k个插入的数，那么在数组中下标是k-1,所以调用时需要使用add(k-1,x)
            add(k - 1, x);
        }
    }
    //遍历单链表
    for (int i = head; i != -1; i = ne[i])cout << e[i] << " ";
    return 0;
}
```



**Day15.(2023.2.22)**

#### 数组模拟双链表（优化某些问题）

每一个点有两个指针

用下标为0的点表示头节点（左端点），为1的表示尾节点（右端点）

<img src="https://img2022.cnblogs.com/blog/2425439/202205/2425439-20220511115451090-15263877.png" style="zoom: 43%;" />

Left：左端点，right，右端点。这两个不算在链表里，所以在最左侧插入数就是在left右边插入。

为什么单链表用了头节点head，而双链表直接用01表示两端，这是因为大部分题目就用这样的操作可以解决。

0是左端点，因此r[0]=1, 1是右端点，l[1]=0

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230222091524768.png" alt="" style="zoom:38%;" />

现在写的是在k的右边插入一个点，如果想在k的左边插入一个点，可以写成add(l[k],x)

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230222125157324.png" style="zoom:38%;" />

这个是删除操作。

拿邻接表存储树和图放到第三章讲，这个双链表确实很难理解，只有自己多画图，然后结合着代码理解。

##### 双链表模板：

```csharp
int e[N];
int l[N];
int r[N];

//初始化
void init()
{
    // 0表示左端点（head）， 1表示右端点（tail）
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

//在下标是k的点的右边，插入x
void add(int k, int x)
{
    e[idx] = x;
    r[idx] = r[k]; //不能用 k + 1
    l[idx] = k;
    
    l[r[k]] = idx; //不能用 k + 1
    r[k] = idx;
    
}

//在k的左边插入x
add(l[k], x);

//删除第k个点
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}
```

##### ACWING:827

```cpp
/*双链表
实现一个双链表，双链表初始为空，支持5种操作：
在最左侧插入一个数；
在最右侧插入一个数；
将第 k个插入的数删除；
在 第 k个插入的数左侧插入一个数；
在第 k个插入的数右侧插入一个数
现在要对该链表进行 M次操作，进行完所有操作后，从左到右输出整个链表。
注意:题目中第 k个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n个插入的数。
输入格式
第一行包含整数 M，表示操作次数。接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：
L x，表示在链表的最左端插入数 x。
R x，表示在链表的最右端插入数 x。
D k，表示将第 k个插入的数删除。
IL k x，表示在第 k个插入的数左侧插入一个数。
IR k x，表示在第 k个插入的数右侧插入一个数。
输出格式
共一行，将整个链表从左到右输出。
数据范围
1≤M≤100000
所有操作保证合法。
输入样例：
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
输出样例：
8 7 7 3 2 9
*/
/*思路：
开三个数组
e[]用来存储数值
l[]用来存储前驱（左边数的下标）
r[]用来存储后继（右边数的下标）
idx用来记录当前下标
定义几个函数然后调用函数接着就ac了~*/
#include<bits/stdc++.h>
using namespace std;
const int N =1e5+10;
int e[N],r[N],l[N],idx;
//e用来存储数值，l[]用来存储前驱（左边数的下标），r[]用来存储后继（右边数的下标），idx用来记录当前下标
void init() {//初始化
    //0是左端点，1是右端点 
    r[0]=1;
    l[0]=0;
    idx=2;
} 
void add_to_right(int k,int x) {//在k右边插入x
    e[idx]=x;//将x存入当前下标的数值数组中 
    r[idx]=r[k];//当前下标的后继为k的后继 
    l[idx]=k;//当前下标的前驱为k 
    l[r[k]]=idx;//k的后继节点的前驱为idx 
    r[k]=idx++; //k的后继节点为idx； idx++； 
} 
void add_to_left(int k,int x) {//在k的左边插入x 
  	add_to_right(l[k],x);//等价于在k的前驱的右边插入x 
}
void remove(int k)  {//删除第k个结点
  	r[l[k]]=r[k];//k的前驱的后继为k的后继
	  l[r[k]]=l[k];//k的后继的前驱为k的前驱 
}   
void add_to_head(int x ) {//在链表的最左端插入数x
   	add_to_right(0,x);//在0的后面插入x 
} 
void add_to_tail(int x)	{//在链表的最右端插入数x
		add_to_right(l[1],x);
} 
int main() {
		int m;
		init();
		scanf("%d",&m);
		while(m--) {
        string c;
        cin>>c;
        if(c=="L") {
            int x;
            scanf("%d",&x);
            add_to_head(x);
        }else if(c=="R") {
            int x;
            scanf("%d",&x);
            add_to_tail(x);
        }else if(c=="D") {
            int k;
            scanf("%d",&k);
            remove(k+1);
        }else if(c=="IL") {
            int k,x;
            scanf("%d%d",&k,&x);
            add_to_left(k+1,x);
        }else {
            int k,x;
            scanf("%d%d",&k,&x);
            add_to_right(k+1,x);
        }
    } 
    for(int i=r[0];i!=1;i=r[i]) {
        printf("%d ",e[i]);
    }
    printf("\n");
    return 0;
} 
```



**Day16.(2023.2.23)**

#### 邻接表 存储树和图

![](https://segmentfault.com/img/remote/1460000039206214)

![](https://segmentfault.com/img/remote/1460000039206215)



### 栈与队列（吐出来的是栈，拉出来的是队列）

刷题 acwing 828的时候看到x的范围是在1<=x<=10^9，就看了下c++整型，长整型的表示范围。

signed int 4B，(-2^32)/2 -> (2^32)/22-1 （长度是10位）

signed long 4B, (-2^32)/2 -> (2^32)/22-1 （长度是10位）

signed long long 8B. (-2^64)/2 -> (2^64)/22-1

首先学习用数组来模拟栈和队列：

#### 数组模拟栈：先进后出，从队尾插入队尾取出

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

##### ACWING:828

```cpp
/*828.模拟栈
实现一个栈，栈初始为空，支持四种操作：
1. push x – 向栈顶插入一个数 x；
2. pop – 从栈顶弹出一个数；
3. empty – 判断栈是否为空；
4. query – 查询栈顶元素。
现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4都要输出相应的结果。
输入格式
第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式
对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。
数据范围
1≤M≤100000
1≤x≤10^9
所有操作保证合法。
输入样例：
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
输出样例：
5
5
YES
4
NO
*/
/*用数组模拟实现：
①第一个元素时n == 1
②n是全局变量，初始值为0
③按照题目要求，三四两步最后加回车*/
#include <iostream>
using namespace std;
const int N=100010;
//tt是栈顶指针
int stk[N],tt;
void push(int x) {
    stk[tt]=x;
    tt++;
}
void pop() {
    tt--;
}
bool empty() {
    if(tt==0) return true;
    else return false;
}
int query() {
    if(!empty()) return stk[tt-1];
}
int main() {
    tt = 0;
    int m;
    cin >> m;
    string s;
    int x;
    while(m--) {
        cin>>s;
        if(s=="push") {
            cin>>x;
            push(x);
        }else if(s=="pop") {
            pop();
        }else if(s=="empty") {
            bool tmp=empty();
            if(tmp) cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
        }else {
            cout<<query()<<endl;
        }
    }
    return 0;
}
```

#### 数组模拟队列：先进先出，在队尾插入，队头取出

```cpp
//1. 普通队列：
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}

//2. 循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}

```

##### ACWING:829

```cpp
/*829.模拟队列
实现一个队列，队列初始为空，支持四种操作：
push x – 向队尾插入一个数 x；
pop – 从队头弹出一个数；
empty – 判断队列是否为空；
query – 查询队头元素。
现在要对队列进行 M个操作，其中的每个操作 3 和操作 4都要输出相应的结果。
输入格式
第一行包含整数 M，表示操作次数。
接下来 M行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式
对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或NO，query 操作的查询结果为一个整数，表示队头元素的值。
数据范围
1≤M≤100000,
1≤x≤10^9,
所有操作保证合法。
输入样例：
10
push 6
empty
query
pop
empty
push 3
push 4
pop
query
push 6
输出样例：
NO
6
YES
4
*/
/*思路：
队列：是一个特殊的数组，最前面的叫做队头，最后面的叫做队尾，只允许在队头删除元素，在队尾插入元素。先进先出。
用一个数组q保存数据。
用hh表示队头，q[hh]即队头元素，q[hh+1]即第二个元素。
用tt表示队尾，q[tt]就是队尾元素，q[tt+1]就是下一次入队，元素应该放的位置。
[hh,tt]左闭右闭，代表队列中元素所在的区间。
出队pop：因为hh为队头，[hh,tt]代表元素所在区间。所以出队可以用hh++实现，hh++后，区间变为[hh+1,tt];
入队push：因为tt代表队尾，[hh,tt]代表元素所在区间，所以出队可以用tt++实现，tt++后，区间变为[hh,tt+1]，然后再q[tt+1]位置放入入队元素。
是否为空empty：[hh,tt]代表元素所在区间，当区间非空的时候，队列非空，也就是tt>=hh的时候，队列非空。
询问队头query：用hh代表队头，q[hh]就是队头i元素，返回q[hh]即可。*/
#include<iostream>
using namespace std;
const int N = 100010;
//q[]表示队列 hh表示队头 tt表示队尾
int q[N];
int hh = 0, tt = -1;//最开始下标为0开始的队列
int main() {
    int m, x;
    string op;
    cin >> m;
    for(int i = 0; i < m; i ++) {
        cin >> op;
        if(op == "push") {
            cin >> x;
            q[++ tt] = x;//向队列插入元素
        }else if(op == "pop") {
            hh ++;//弹出队头元素
        }else if(op == "query") {
            cout << q[hh] << endl;//查询队头元素
        }else {
            if(hh <= tt) {//不为空
                cout << "NO" << endl;
            }else {//为空
                cout << "YES" << endl;
            }
        }
    }
    return 0;
}
```



### 单调栈和单调队列（优化暴力，去掉中间没有用的元素，剩下元素有单调性可以做优化）

#### 单调栈：求滑动窗口最大值、最小值

eg：（左\右边有没有大\小的数） 变成严格单调上升的栈

给定一个序列，让我们求序列中的每个数的 左边离他最近的，且比它小的数（单调队列也一样）先想暴力解法，然后怎么优化（弄个单调序列出来）。

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230223211156510.png" style="zoom:60%;" />

当把左边比右边大的数删掉后，会变成一个严格单调上升的栈。

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230223211241755.png" style="zoom:60%;" />



##### 单调栈算法模板：

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

##### ACWING:830

```cpp
/*830.单调栈
给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。
输入格式
第一行包含整数N，表示数列长度。
第二行包含N个整数，表示整数数列。
输出格式
共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。
数据范围
1≤N≤10^5 1≤数列中元素≤10^9
输入样例：
5 3 4 2 7 5
输出样例：
-1 3 -1 2 2*/
/**/
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;
int main() {
    int n;
    cin >> n;
    while (n -- ) {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) //当栈是不空的并且栈里的元素是大于当前这个数字的，那么栈里的元素就不会被用到   
            tt -- ;
        if (!tt) printf("-1 ");//如果都大于，说明没有，就输出-1 
        else printf("%d ", stk[tt]);//如果存在小于的，就输出 
        stk[ ++ tt] = x;//然后把x放进去 
    }
    return 0;
}
```

#### 单调队列

eg：求滑动窗口的最大值\最小值

q里面装的是数组a的下标，hh指的是当前滑动窗口最小值的下标存储在q中的哪个位置，tt指的是当前滑动窗口（去除掉左边比右边大的数后，严格单调上升）的尾端（即当前滑动窗口转换成严格单调上升后最大数的下标）在q的哪个位置。

##### 单调队列算法模板：

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

##### ACWING:154

```cpp
/*154.滑动窗口
给定一个大小为 n≤10^6的数组。
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 [1 3 -1 -3 5 3 6 7]，k
为 3 。
窗口位置	最小值	最大值
[1 3 -1] -3 5 3 6 7	-1	3
1 [3 -1 -3] 5 3 6 7	-3	3
1 3 [-1 -3 5] 3 6 7	-3	5
1 3 -1 [-3 5 3] 6 7	-3	5
1 3 -1 -3 [5 3 6] 7	3	6
1 3 -1 -3 5 [3 6 7]	3	7
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
输入格式
输入包含两行。
第一行包含两个整数 n
和 k ，分别代表数组长度和滑动窗口的长度。
第二行有 n 个整数，代表数组的具体数值。
同行数据之间用空格隔开。
输出格式
输出包含两个。
第一行输出，从左至右，每个位置滑动窗口中的最小值。
第二行输出，从左至右，每个位置滑动窗口中的最大值。
输入样例
8 3
1 3 -1 -3 5 3 6 7
输出样例
-1 -3 -3 -3 3 3
3 3 5 5 6 7
*/
/*题目思路
用单调队列的思想，如输出最小值时，
入队前将比当前数字大的从队尾出队，输出结果时输出队头，维护一个长度1<=队列长度<=滑动窗口得队列。*/
#include <iostream>//三步
using namespace std;
const int N = 1e6 + 10;
int hh = 0, tt = -1, n, k, a[N], q[N];//a数组存数字,q数组是单调队列存下标
int main() {
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n; i++)
        scanf("%d",&a[i]);//先存完再进行滑动窗口操作
    for(int i = 0; i < n; i ++ ) {
    //判断队列非空  hh <= tt
    //1.队首是否滑出滑动窗口
    //滑动窗口下标大于对首下标则说明队首滑出滑动窗口，需剔除队首
        if(hh <= tt && i - k + 1 > q[hh])  hh++;
    //先求最小值
    //2.为了保持单调队列的单调性，需在队尾进行删除操作。如：数组为 3 5 ,新进入的滑动窗口
    //数字为4，若在队首进行删除，那么3<4,那么就不用进行删除操作。数组就为3 5 4
    //不满足单调情况。而在队尾进行删除操作，因为5>4，3<4，所以5被删除，留下数组3 4
    //具有单调性
        while(hh <= tt && a[i] <= a[q[tt]])  tt--;
        q[ ++ tt] = i;//一定要在前两步操作后与下一步操作前存入
    //3.必须在滑动窗口有三个元素时输出。若滑动窗口内只有两个元素，则不输出
        if(i >= k - 1)    printf("%d ", a[q[hh]]);//对头为最小元素
    }
    puts("");//换行符
    //求最大值同理
    hh = 0, tt = -1;//hh tt值在求最小值时改变了，需得重新初始化
     for(int i = 0; i < n; i ++) {
        if(hh <= tt && i - k + 1 > q[hh])  hh ++;
        while(hh <= tt && a[i] >= a[q[tt]])  tt --;
        q[ ++ tt] = i;
        if(i >= k - 1)    printf("%d ", a[q[hh]]);
    }
    return 0;
}
```

### kmp算法（克努特-莫里斯-普拉特操作）

- kmp整体思路

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230223211934094.png" style="zoom:40%;" />

Next[i]=j是指，模板串中以i为终点的长度为j的这段和模板串1，j的部分是相等的，即p[1,j]=p[i-j+1,i]

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230224064403434.png" style="zoom:40%;" />

移动的时候，其实就是找以这个点（竖着的那条绿色的线）为终点的后缀和前缀相等的时候（将模板串p往后移）

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230224190233338.png" style="zoom:40%;" />

模式串S和模板串P的匹配过程是清楚了，但是Next数组的求取过程还没不能够很清楚明了的知道求解过程。

##### Kmp算法模板

```cpp
void getNext(vector<int>& next, string x){
        //i:后缀尾位置，j:前缀尾位置（也是长度）
        int j = 0;
        //初始化next数组
        next.push_back(0);
        
        for(int i = 1; i < x.length(); i++){
            while(j > 0 && x[i] != x[j] ) j = next[j - 1]; //处理不同情况
            if(x[i] == x[j]) j++; //处理相同情况
            next.push_back(j); //更新next数组
        }
    }
    int strStr(string text, string son) {
        //i:文本串位置，j:子串位置
        vector<int> next;
        getNext(next, son);
        int j = 0; 
        for(int i = 0; i < text.size(); i++){
            while(j > 0 && text[i] != sonson[j]) j = next[j - 1]; //处理不同情况
            if(text[i] ==son[j]) j++; //处理相同情况
            ... //根据题目要求操作
        }
        return -1;
    }
```

问题：在文本串中找子串

例子：在aabaabaaf中找aabaaf

遍历子串得到next数组（最大相等前后缀长度）

文本串中寻找子串存在的位置

根据next数组更新位置

**next数组情况分析：**

| 0    | 1    | 0    | 1    | 2    | 0    | 最大相等前后缀长度 | j = next[j - 1] |
| ---- | ---- | ---- | ---- | ---- | ---- | ------------------ | --------------- |
| -1   | 0    | 1    | 0    | 1    | 2    | 右移一位           | j = next[j]     |
| -1   | 0    | -1   | 0    | 1    | -1   | 每个位置-1         | j = next[j] + 1 |

[从头到尾彻底理解KMP（2014年8月22日版）_结构之法 算法之道-CSDN博客_kmp](https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request%5Fid%22%3A%22163774099916780265432000%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=163774099916780265432000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-7041827.pc_search_es_clickV2&utm_term=kmp&spm=1018.2226.3001.4187)

1、p[ ]是模板串，即比较短的字符串。
2、s[ ]是模式串，即比较长的字符串。
3、“非平凡前缀”：指除了最后一个字符以外，一个字符串的全部头部组合。
4、“非平凡后缀”：指除了第一个字符以外，一个字符串的全部尾部组合。
5、“部分匹配值”：前缀和后缀的最长共有元素的长度。
6、next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。
KMP核心思路：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次有可能匹配成功的位置,即next[j]，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。
next数组的含义：next[j]的含义是指模板串p[1,next[j]]与p[j-next[j]+1,j]完全相等，下面以字符串p = "abcab"为例求next数组

| p      | a    | b    | c    | a    | b    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 下标   | 1    | 2    | 3    | 4    | 5    |
| next[] | 0    | 0    | 0    | 1    | 2    |

对next[ 1 ] ：前缀 = 空集—————后缀 = 空集—————next[ 1 ] = 0;
对next[ 2 ] ：前缀 = { a }—————后缀 = { b }—————next[ 2 ] = 0;
对next[ 3 ] ：前缀 = { a , ab }—————后缀 = { c , bc}—————next[ 3 ] = 0;
对next[ 4 ] ：前缀 = { a , ab , abc }—————后缀 = { a . ca , bca }—————next[ 4 ] = 1;
对next[ 5 ] ：前缀 = { a , ab , abc , abca }————后缀 = { b , ab , cab , bcab}————next[ 5 ] = 2;
s[a,b] = p[1,j] && s[i] != p[j + 1]此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）
其中1串为[ 1, next[ j ] ]，3串为[j-next[j]+1,j]。由匹配可知 1串等于3串，3串等于2串。所以直接移动p串使1到3的位置即可。这个操作可由j = next[j]直接完成。 如此往复下去，当j == m时匹配成功。

##### ACWING:831

暴力算法

```cpp
/*831.Kmp字符串暴力匹配算法
假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？
    如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：
如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；
如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。
    暴力匹配的代码，如下：*/
int ViolentMatch(char* s, char* p)
{
	int sLen = strlen(s);
	int pLen = strlen(p);
 
	int i = 0;
	int j = 0;
	while (i < sLen && j < pLen)
	{
		if (s[i] == p[j])
		{
			//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    
			i++;
			j++;
		}
		else
		{
			//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    
			i = i - j + 1;
			j = 0;
		}
	}
	//匹配成功，返回模式串p在文本串s中的位置，否则返回-1
	if (j == pLen)
		return i - j;
	else
		return -1;
}
```

Kmp算法

```cpp
/*831.Kmp字符串
给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模板串P在模式串S中多次作为子串出现。
求出模板串P在模式串S中所有出现的位置的起始下标。
输入格式
第一行输入整数N，表示字符串P的长度。
第二行输入字符串P。
第三行输入整数M，表示字符串S的长度。
第四行输入字符串M。
输出格式:共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。
数据范围:1≤N≤10^4    1≤M≤10^5
输入样例：
3
aba
5
ababa
输出样例：
0 2*/
#include <iostream>
using namespace std;
const int N = 10010, M = 100010;
int n, m;
int ne[N];
char s[M], p[N];
int main() {
    cin >> n >> p+1 >> m >> s+1;        	//下标从1开始
    for(int i = 2, j = 0; i <= n; i++) { 	//i = 1时next数组为0
        while(j && p[i] != p[j+1]) j = ne[j];
        if(p[i] == p[j+1]) j++;
        ne[i] = j;    
    }
    for(int i = 1, j = 0; i <= m; i++) {
        while(j && s[i] != p[j+1]) j = ne[j];
        //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
        if(s[i] == p[j+1]) j++;//当前元素匹配，j移向p串下一位
        if(j == n) {			//匹配成功，进行相关操作
            cout << i-n << ' ';
            j = ne[j];      //找到完全匹配的字符串后重新从p的ne[n]位置开始搜索
        }
    }
}
```



**Day17.(2023.2.24)**

### Trie树（字典树）

- 快速存储和查找字符串集合的数据结构
- 按照每个字符串顺序进行建树，标记字符串结尾的地方/标记出现次数

![image](https://segmentfault.com/img/remote/1460000039216219)

字符串集合是{in, inn, int, tea, ten, to}

##### Tire树模板：

```cpp
//每个点存的是数字
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

##### ACWING:835

```cpp
/*835.Tire字符串统计
维护一个字符串集合，支持两种操作：
I x 向集合中插入一个字符串 x；
Q x 询问一个字符串在集合中出现了多少次。
共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。
输入格式
第一行包含整数 N，表示操作数。
接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。
输出格式
对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。
每个结果占一行。
数据范围
1≤N≤2∗10^4
输入样例：
5
I abc
Q abc
Q ab
I ab
Q ab
输出样例：
1
0
1*/
#include <iostream>
#include <cstring>
using namespace std;
const int N = 100010;
int cnt[N];//存储以下标为结尾的字符串的出现的次数
int son[N][26];//至多有N个字符，即N个结点，每个结点至多有26个子节点
int idx = 0;//用于标识节点的索引，初始值为0，根结点的idx为空
/**
    Trie树,字典树，用于存储和快速查找字符串，一般字符串内容是纯大写字母或者纯小写字母或者数字
**/
//将某个字符串插入到字典树中
void insertStr(char str[]) {
    int p = 0;//根节点的索引
    for(int i = 0; str[i]; i++) {
        int next_idx = str[i] - 'a';//求下一个字符所在的结点的索引
        if(!son[p][next_idx]) son[p][next_idx] = ++idx;//如果下一个字符str[i]不存在,则创建该字符对应的结点，标识idx自增。根节点或者尾节点的idx为0
        p = son[p][next_idx];//更新下一个字符所在节点的索引
    }
    cnt[p]++;//以下标为p结尾的某个字符串
}
int query(char str[]) {
    int p = 0;
    for(int i= 0; str[i]; i++) {
        int next_idx = str[i] - 'a';//求下一个字符所在的结点的索引
        if(!son[p][next_idx]) return 0;//如果当前字符不存在，则直接返回
        p = son[p][next_idx];//更新下一个字符所在节点的索引
    }
    return cnt[p];//返回以p标识的结点为结尾的字符串 出现的次数
}
int main() {
    int n;
    cin >> n;
    while( n -- ) {
        char op[2], str[N];
        scanf("%s%s", op, str);
        if(op[0] == 'I')  insertStr(str);
        else cout << query(str) << endl;
    }
    return 0;
}
```

变型题：

##### ACWING:143

```cpp
```



### 并查集（近乎O(1)）

1. 功能：

   - 将两个集合合并
   - 询问两个元素是否在一个集合当中

2. 基本原理

   - 每个集合用一颗树来表示，树根编号就是整个集合的编号，每个节点存储他的父节点（p[x]）

3. 操作

   - 问题1：如何判断树根：if(p[x] == x)
   - 问题2：如何求x的集合编号：while(p[x] != x) x = p[x]
   - 问题3：如何合并两个集合，p[x]是x的集合编号，p[y]是y的集合编号，p[x] = y

4. 优化

   - 查一次之后直接指向祖先（路径压缩）

     <img src="https://segmentfault.com/img/remote/1460000039216220" style="zoom:50%;" />

   <img src="https://segmentfault.com/img/remote/1460000039216216" style="zoom:50%;" />

   - 路径压缩：

   <img src="https://segmentfault.com/img/remote/1460000039216218" style="zoom:50%;" />
   <img src="https://segmentfault.com/img/remote/1460000039216217" style="zoom:50%;" />

5. 统计一个集合中数的数量（size[i]）

   - 合并集合：if(b的根节点 != a的根节点) size[b的根节点] += size[a的根节点]

##### 并查集模板：

```cpp
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);


(2)统计每个集合有多少个元素的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230225105918668.png" style="zoom:50%;" />

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230225110057539.png" style="zoom:40%;" />

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230225105955237.png" style="zoom:40%;" />

这里实现了最常用路径压缩优化，一般不写按秩合并这个优化（用处不大）

##### ACWING:836

```cpp
/*836.合并集合
一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
现在要进行 m 个操作，操作共有两种：
M a b，将编号为 aa 和 bb 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
Q a b，询问编号为 aa 和 bb 的两个数是否在同一个集合中；
输入格式
第一行输入整数 n 和 m。
接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。
输出格式
对于每个询问指令 Q a b，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1≤n, m≤105
输入样例：
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
输出样例：
Yes
No
Yes
*/
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int p[N]; // 当前节点的父节点；
// 该函数的含义：查找a所在集合的祖先节点下标，从1开始, 并内部更新p[a]为a节点的祖先节点。
int find(int a) {
    // 根据通项公式，假设p[a]的祖先节点已知。
    if (p[a] != a) p[a] = find(p[a]);
    return p[a];
}
int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    // 初始化每个集合
    for (int i = 1; i <= n; i++) p[i] = i;
    int a, b;
    char op[2];
    while (m -- ) {
        scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'M') p[find(a)] = find(b);
        else {
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

优化

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1e5 + 10;
string s;
int p[N], n, m, x, y;
int find(int x) {//查找集合与路径压缩
    if(p[x] != x) return p[x] = find(p[x]);
    return x;
}
int main() {
    scanf("%d%d", &n,  &m);
    for(int i = 1; i <= n; ++i)  p[i] = i;
    while(m -- ) {
        cin >> s;
        scanf("%d%d", &x, &y);
        if(s == "M") p[find(x)] = find(y); //一定要用父节点合并这样才能保证根节点唯一
        else printf("%s\n", find(x) == find(y) ? "Yes":"No");
    }
    return 0;
}
```

在并查集的这个操作过程中，额外维护一些变量

只有根节点的size是有意义的，只需要在合并操作的时候更新size集合就可以了



**Day18.(2023.2.25)**

##### ACWING:837

```cpp
/*837.连通块中点的数量
给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。
现在要进行 m 个操作，操作共有三种：
C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
Q2 a，询问点 a 所在连通块中点的数量；
输入格式
第一行输入整数 n 和 m。
接下来 m 行，每行包含一个操作指令，指令为 C a b，Q1 a b 或 Q2 a 中的一种。
输出格式
对于每个询问指令 Q1 a b，如果 a 和 b 在同一个连通块中，则输出 Yes，否则输出 No。
对于每个询问指令 Q2 a，输出一个整数表示点 a 所在连通块中点的数量
每个结果占一行。
数据范围
1≤n,m≤105
输入样例：
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
输出样例：
Yes
2
3*/
#include <iostream>
using namespace std;
const int N = 100010;
int p[N], cnt[N];//父节点数组p[] 集合/连通块的元素个数数组cnt[]
//查找某个元素的所在集合，即返回所在集合的根节点的值，路径压缩优化
int find(int x) {
    if(p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}
int main() {
    //优化输入
    ios::sync_with_stdio(false);
    int n, m;
    cin>>n>>m;
    //初始化并查集的p数组
    for(int i = 1; i <= n; i++)
        p[i] = i, cnt[i] = 1;//每个集合或者说连通块的初始元素个数为1
    while(m --) {
        char op[5];
        scanf("%s", op);
        int a, b;
        if(op[0] == 'C') {
            scanf("%d%d", &a, &b);
            int pa = find(a);//a所在连通块的根节点的值
            int pb = find(b);//b所在连通块的根节点的值
            if(pa != pb)//如果a和b不在同一个连通块/集合
            {
                p[pa] = pb;//将a所在集合合并到b所在的集合
                cnt[pb] += cnt[pa];//b所在连通块/集合的元素个数 += b所在连通块/集合的元素个数
            }
        }
        else if(op[1] =='1') {
            scanf("%d%d", &a, &b);
            if(find(a) == find(b)) puts("Yes");
            else puts("No");
        }
        else if(op[1] == '2') {
            scanf("%d", &a);
            cout<<cnt[find(a)]<<endl;//输出a所在连通块/集合的元素个数
        }
    }
    return 0;
}
```



**Day19.(2023.2.26)**

ACWING:240

```cpp
```



### 堆（是一个完全二叉树：除最后一层，都是满的，最后一层从左向右排列）

eg: 小根堆，每一个点小于左右儿子

- 用一维数组存储， 左儿子2x, 右儿子2x+1
- 下标从1开始

| 操作             | 代码                                         |
| ---------------- | -------------------------------------------- |
| 插入一个数       | heap[++size] = x up(size)                    |
| 求集合中的最小值 | heap[1]                                      |
| 删除最小值       | heap[1] = heap[size]; size--; down(1)        |
| 删除任意一个元素 | heap[k] = heap[size]; size--; down[k]; up[k] |
| 修改任意一个元素 | heap[k] = x; down[k]; up[k]                  |

##### 堆模板

```cpp
int h[N], size;

//down
//把一个值变大时候down
//跟左右节点的最小值交换
void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)  //最小值的下标不同的话
    {
        swap(h[u], h[t]);
        down(t);
    }
}
//up
//把一个值变小时候up
//跟父节点交换，因为小根堆
void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        swap(h[u], h[u / 2]);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

##### ACWING:838

```cpp
/*838.堆排序
输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。
输入格式
第一行包含整数 n 和 m。
第二行包含 n 个整数，表示整数数列。
输出格式
共一行，包含 m 个整数，表示整数数列中前 m 小的数。
数据范围
1≤m≤n≤10^5，
1≤数列中元素≤10^9
输入样例：
5 3
4 5 1 3 2
输出样例：
1 2 3
*/
/*思路：
堆的常用操作：
1.插入一个数 h[++size] = num; up(size);
2.求集合当中的最小值 h[1];
3.删除最小值 h[1] = h[size];size--; down(1);
4.删除任意一个元素 h[k] = h[size]; size--; down(k), up(k);//down和up都执行一遍，只会执行一种，就不用判断再执行，方便代码编写和记忆
5.修改任意一个元素 h[k] = num; down(k), up(k); //down和up都执行一遍，只会执行一种，就不用判断再执行，方便代码编写和记忆*/
#include <iostream>
using namespace std;
const int N = 100010;
int h[N], cnt; 
//数组存储堆的节点，下标从1开始, 节点x的左孩子节点下标为2x,右孩子节点下标为2x+1
//如果下标从0开始，节点x的左孩子节点下标为2x+1,右孩子节点下标为2x+2
//down操作，对堆中下标为u的元素进行一次重新排序
//down的核心思路是节点x,节点2x，节点2x+1进行交换位置，保证三个值中最小值在父节点位置
void down(int u)
{
    int t = u;
    if(u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
    if(u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if(t != u)
    {
        swap(h[u], h[t]);
        down(t);
    }
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    cnt = n;//堆的节点个数，即序列元素总个数
    for(int i = 1; i <= n; i++)
        scanf("%d", &h[i]);
    //生成小根堆,时间复杂度大约是O(n), 从n/2处的节点开始往上遍历节点，并逐一执行down(i)操作,每次down或者up操作跟二叉树的层数成正比，每次操作的时间复杂度为logN
    for(int i = n/2; i; i--)
        down(i);
    while(m --) {
        printf("%d ",&h[1]);
        h[1] = h[cnt];
        cnt -- ;//堆元素个数自减
        down(1);//将交换后的堆顶元素down重新排序成小根堆
    }
    return 0;
}
```

##### ACWING:839

模拟堆这道题就是在原始堆的基础上增加了ph，hp两个数组，表示更多信息，每次操作之后要更新它们俩。

对ph，hp数组的理解：

题目中的“第k个插入的数”描述中的k相当于idx；

ph数组存的是下标，即在堆中的位置；

hp数组里面存的是idx；

而h数组内存的是结点内的值；

对swap的理解：

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230226164222960.png" style="zoom:33%;" />

```cpp
/*839.模拟堆
维护一个集合，初始时集合为空，支持如下几种操作：
I x，插入一个数 x；
PM，输出当前集合中的最小值；
DM，删除当前集合中的最小值（数据保证此时的最小值唯一）；
D k，删除第 k 个插入的数；
C k x，修改第 k 个插入的数，将其变为 x；
现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。
输入格式
第一行包含整数 N。
接下来 N 行，每行包含一个操作指令，操作指令为 I x，PM，DM，D k 或 C k x 中的一种。
输出格式
对于每个输出指令 PM，输出一个结果，表示当前集合中的最小值。
每个结果占一行。
数据范围
1≤N≤105
−109≤x≤109
数据保证合法。
输入样例：
8
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
输出样例：
-10
6*/
//这里ph数组存储结点下标，hp数组存储idx
//这俩数组的意义是维护结点下标与idx的一一对应关系
//size_：1堆结点数量2堆结点下标
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 1e5 + 10;
int h[N],hp[N],ph[N],heap_size = 0;//hp,ph数组元素个数相同，同时等于堆中结点数
//h[]是堆本身，这边假设一个集合p和堆中每个节点存在一一对应关系，即存在映射
//hp则是h to p，利用h中的节点，找到对应p集合中对应的数，ph同理，也可以将ph和hp理解为互相保存对方地址的集合
void heap_swap(int a, int b) {//a，b是堆数组下标，也就是位置，真正交换的是位置中的值
    swap(ph[hp[a]],ph[hp[b]]);//首先要交换p指向h的位置，因为hp要用于索引hp数组，是根基，所以不能先改，参考双向链表删除结点
    swap(hp[a], hp[b]);//其次交换h指向p的位置
    swap(h[a], h[b]);//最后交换两个节点的位置
}
void down(int u) {//同838的笔记
    int t = u;
    if(u * 2 <= heap_size && h[u * 2] < h[t])
        t = u * 2;
    if(u * 2 + 1 <= heap_size && h[u * 2 + 1] < h[t])
        t = u * 2 + 1;
    if(u != t) {
        heap_swap(u, t);
        down(t);
    }
}
void up(int u) {//up函数中u位置结点只与其父节点比较，也可以用一个if语句
    while(u / 2 && h[u / 2] > h[u]) {//同838的笔记
        heap_swap(u / 2, u);
        u /= 2;;//一直递归上浮这个值，直到找到合适位置
        //这里u内的值(下沉过来的值)变大为什么不用递归down(u)?????
    }
}
int main() {
    int n, m = 0;
    cin >> n;
    while(n -- ) {
        string op;
        int k, x;
        cin >> op;
        if(op == "I") {
            scanf("%d", &x);
            heap_size ++;
            m ++;//节点对应的地址形成
            ph[m] = heap_size,hp[heap_size] = m;//绑定互相指的指针
            h[heap_size] = x;//给值
            up(heap_size);//入堆，因为向下没有路，所以只能上浮调整位置
        }else if(op == "PM") {
            printf("%d\n",h[1]);
        }else if(op == "DM") {//理同838
            heap_swap(1,heap_size);
            heap_size--;
            down(1);
        }else if(op == "D") {
            scanf("%d", &k);
            //需要先找到与k对应的堆结点
            int u = ph[k];//找个临时值保存对应位置的指针,相当于idx
            //h[ph[k]]=h[size_--];这种法子不能用了，因为有了附属信息（ph，hp）交换时需要改变它们
            heap_swap(u, heap_size);//把对应的值移到最后面去，值交换后值的下标（位置）改变，值也就是第几个插入的数
            heap_size -- ;//相当于删掉最后一个叶子节点
            up(u);
            down(u);//up和down都要进行一次是因为有可能被替换到中间层
        }else if(op == "C") {
            scanf("%d%d", &k, &x);
            h[ph[k]]=x; 
            down(ph[k]);//涉及不到heap_swap的内容，所以可以直接传ph的值进行操作
            up(ph[k]);
        }
    }
    return 0;
}
```



**Day20.(2023.2.27)**

### 哈希表

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230226211259717.png" alt="i" style="zoom: 33%;" />

hash这个操作是指把一个比较大的数据范围映射到一个比较小的范围。算法题中的hash表一般只有添加和查询操作，没有删除操作。（就算有也不是真的删，而是开个额外数组，打个标记）

##### 一般哈希模板：

```cpp
1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```

##### ACWING:840

#### 第一种方式：拉链法

映射之后为同一个数字的全部存在同一个`h[K]`下面，像一条拉链，这其实也就是我们数组和之前数组模拟[单链表](https://so.csdn.net/so/search?q=单链表&spm=1001.2101.3001.7020)的组合

这里的`h[k]`在拉链里的作用就相当于之前的单链表的头结点

取余的数要选择质数且尽可能要离2的整数次方远（这样的话冲突的概率最小）

<img src="https://img-blog.csdnimg.cn/img_convert/7abcd97611d433aae2eca2b9a1e26e3f.png#pic_center" style="zoom:67%;" />

```cpp
/*840.模拟散列表
维护一个集合，支持如下几种操作：
    I x，插入一个数 x；
    Q x，询问数 x 是否在集合中出现过；
现在要进行 N 次操作，对于每个询问操作输出对应的结果。
输入格式
第一行包含整数 N，表示操作数量。
接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。
输出格式
对于每个询问指令 Q x，输出一个询问结果，如果 xx 在集合中出现过，则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1≤N≤10^5
−10^9≤x≤10^9
输入样例：
5
I 1
I 2
I 3
Q 2
Q 5
输出样例：
Yes
No
在插入和查询时,数据范围过大,会超时,这里可以避免这个问题 
*/
//先采用拉链法
#include<cstring>
#include<iostream>
using namespace std;
//我们哈希表的存储应尽可能采用质数
//因此这里我们需要找一个比100000大的最小质数
/*int main() {
    for(int i = 100000; ;i++) {
        bool flag = true;
        for(int j = 2; j * j < i; j ++) {
            if(i % j == 0) {
                flag = false;
                break;
            }
        }
        if(flag) {
            cout << i;
            break;
        }
    }
    return 0;
}
输出结果是：100003
*/
const int N = 100003;
int h[N], e[N], ne[N], idx;
void insert(int x) {
    int k = (x % N + N) % N;//先进行映射
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}
bool find(int x) {
    int k = (x % N + N) % N;
    for(int i = h[k]; i != -1; i = ne[i]) {
        if(e[i] == x)
            return true;
    }
    return false;
}
int main() {
    int n;
    cin >> n;
    //先把h[N]中所有元素都先指向空（也就是我们规定的-1)
    memset(h, -1, sizeof h);
    while(n -- ) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(*op == 'Q') {
            if(find(x)) puts("Yes");//
            else puts("No");
        }
        else insert(x);
    }
    return 0;
}
```

#### 第二种方法：开放寻址法

<img src="https://img-blog.csdnimg.cn/img_convert/6e87f73ce4057a503acc098d9d027b89.png#pic_center" alt="" style="zoom:67%;" />

开放寻址法一般定义数组长度为最大操作次数的的2-3倍（同样要为质数），一般设定最大值为0x33f3f3f3f。

```cpp
//采用开放寻址法
#include<cstring>
#include<iostream>
using namespace std;
//我们哈希表的存储应尽可能采用质数
//因此这里我们需要找一个比200000大的最小质数
/*int main() {
    for(int i = 200000; ; i++) {
        bool flag = true;
        for(int j = 2; j * j < i; j ++) {
            if(i % j == 0) {
                flag = false;
                break;
            }
        }
        if(flag) {
            cout << i;
            break;
        }
    }
    return 0;
}
输出结果为：200003
*/
const int N = 200003,null = 0x3f3f3f3f;
//相对于拉链法的优势就是只需要一个数组
int h[N];
//核心操作就是这个find函数
/*find函数的作用是，如果映射的k对应的h[k]上没有的别的元素占领（包括自己）
就return k，此时表示我应该插入的k值
*/
/*
如果映射的k对应的h[k]上就是x自己，则此时return k的意义就是获取x在h[]数组中的位置
*/
/*
如果映射的k对应的h[k]上占领的不是自己，并且h[k]不是空的
表明此时是其他人已经占领了k，所以我们需要找下一个坑
所以k++一直往下找，知道找到合适的
*/
int find(int x) {
    int k = (x % N + N) % N;
    while(h[k] != null && h[k] != x) {
        k ++;
        if(k == N) k = 0;
    }
    
    return k;
}
int main() {
    int n;
    cin >> n;
    //先把h[N]中所有元素都先指向0x3f（h中是int，四个字节，组合起来的ox3f3f3f3f就是我们定义的无穷值null)
    memset(h, 0x3f, sizeof h);
    while(n -- ) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(*op == 'I') {
            h[find(x)] = x;
        } else {
            if(h[find(x)] == null) puts("No");//puts自带换行输出
            else puts("Yes");
        }
    }
    return 0;
}
```



#### 字符串hash（字符串前缀hash）

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230227164511774.png" style="zoom: 45%;" />

这里假定模的值是2^64，但是我用Python实验的时候发现不得行。（存有疑惑，按照y总讲的，不应该取个质数么，然后我试了个质数91815541可以）

但C++ 中unsigned long long相当于直接对2^64取模了，所以源代码中就没有相应的取模操作。

##### ACWING:841

```cpp
/*841.字符串哈希
给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1，r1，l2，r2，请你判断 [l1，r1] 和 [l2，r2] 这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。
输入格式
第一行包含整数 n 和 m，表示字符串长度和询问次数。
第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。
接下来 m 行，每行包含四个整数 l1，r1，l2，r2，表示一次询问所涉及的两个区间。
注意，字符串的位置从 1 开始编号。
输出格式
对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1 ≤ n，m ≤ 10 ^ 5
输入样例：
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
输出样例：
Yes
No
Yes
*/
/*思路分析：
字符串哈希算法用来快速判断两段字符串是否相同，我们实际上是将字符串看成是一个P进制的数，其中P一般为131或13331这样产生冲突的概率会很小，可以理解为几乎没有冲突；一开始的时候使用O(n)的时间预处理一个字符串所有前缀的哈希值，然后我们就可以使用O(1)的时间查询出字符串的哈希值，这样就可以快速判断两个字符串是否相等，字符串哈希一般涉及到下图中的公式，包括计算一个字符串的哈希值，计算字符串中子串的哈希值等。下图是计算一个字符串的P进制数字的相关计算公式：
*/
#include <iostream>
using namespace std;
const int N = 1e5 + 10,P = 131;
//因为ASCII码范围为 0~127，共 128个，按照经验来说，一般取 131（128 + 3）或13331，这样产生冲突的概率低
typedef unsigned long long ULL;
//选用ULL第一点是因为P一旦次方数高了以后会出现很范围大的数
//第二点unsigned long long的范围是[0,2^64 - 1],所以超范围之后会自动进行%2^64操作
int n,m;
char str[N];
ULL h[N],p[N];
//首先是str看成是一个p进制的数，每位字符用ASCII码替代
//利用前缀哈希求出子串哈希 e.g. hash(def) = hash(abcdef) - hash(abc) * P ^ 3
ULL get(int l,int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
    //写成平常公式就是 h[r] - h[l - 1] * P^(r-l+1)
}
int main()
{
    scanf("%d%d%s", &n, &m, str + 1);
    p[0] = 1;
    for(int i = 1; i <= n; i ++) {
        h[i] = h[i - 1] * P + str[i];//左移一位然后加上新的字母的ASCII
        p[i] = p[i - 1] * P;//提高次幂
    }
    while(m -- ) {
        int l1, l2, r1, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);//cin >> l1 >> r1 >> l2 >> r2;
        if(get(l1,r1) == get(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

**注意点：**

串内任何数据（除去\0，因为它的ASCII为0，也正因如此不用考虑串结尾）都不要映射成p进制下的0，如下例：

e.g. 设A为0，则“A”为0，“AAAA”也为0，冲突了。

本题是在假设不会冲突的前提下提出的。



### C++STL

#### 概览

```cpp
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()	返回第一个数/最后一个数
    push_back()/pop_back()	最后插入一个数/删除最后一个数
    begin()/end()	迭代器，返回第一、零个数/最后一个数后一个数
    []	随机寻址
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty() 返回字符串是否为空
    clear() 清空字符串
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈 （加强版的vector O(1)）
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back() 返回第一个元素/返回最后一个函数
    push_back()/pop_back() 最后插入/弹出最后
    push_front()/pop_front() 队首插入元素/队首弹出元素
    begin()/end()
    [] 随机寻址

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset//set不能重复元素：忽略
        insert()  插入一个数
        find()  查找一个数，不存在返回end迭代器
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```

#### Vector，变长数组，倍增的思想

1.初始化

- 数组初始化 int a[5] = {1,2,3,4,5}
- vector初始化 vector<int> A[10] = {1,2,3,4,5}
- vector<int> A(10, 1);

2.二维数组初始化赋值

- vector<vector<int>> f1(n, vector<int>(m,0));

3.常用函数

- 排序：sort(nums.begin(), nums.end());
- 插入：nums.insert(nums.begin(), x);
- 插入：nums.insert(nums.begin() + n , x);
- 删除：nums.erase(nums.begin());
- 返回元素个数：size()
- 返回是否为空：empty()
- 清空：clear()
- 末尾添加/删除：push_back()/pop_back()
- front()/back()
- 返回开始和结束的迭代器：begin()/end()
- []
- 支持比较运算（>,<），按字典序
- erase() (1) 输入是一个数x，删除所有x O(k + logn) k是x的个数
- 去重 alls.erase(unique(alls.begin(), alls.end()), alls.end());
- 查找 -- vector中的find()

vector<int>::iterator result = find(arr2.begin( ), arr2.end( ), arr1[i]);

if ( result == arr2.end( ) ) //如果没找见

4.遍历

- for(vector<int>::iterator i = a.begin(); i != a.end(); i++) cout << *i << endl;
- for(auto i = a.begin(); i != a.end(); i++) cout << *i << endl;
- for(auto x : a) cout << x << endl;

5.参数

- int rows=triangle.size();//求得行数
- int col=triangle[0].size();//求的列数

##### 案例：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    vector<int> a(10, 3);//初始化长度为10的数组
    for (auto x : a) cout << x << ' ';
    cout << endl;
    vector<int> b;
    for (int i = 0; i < 10; i ++ ) b.push_back(i);
    //1、数组下标遍历
    for (int i = 0; i < b.size(); i ++ ) cout << b[i] << ' ';
    cout << endl;
    //2、vector迭代器遍历
    for (vector<int>::iterator i = b.begin(); i != b.end(); i ++ ) cout << *i <<' ';//b.begin() = b[0], b.end = b[b.size], vector<int>::iterator = auto系统自动推断函数类型
    cout << endl;
    //3、范围遍历(C++11新特性)
    for (auto x : b) cout << x << ' ';
    cout << endl;
    //比较运算：字典序
    vector<int> c(4, 3), d(3, 4);//3333 444前者字典序较小
    if (c < d) puts("c < d");
    return 0;
}
```

#### pair<int, int>

1. 定义

- pair底层是结构体
- pair<int, string> 存储一个二元组
- pair<int, pair<int, int>> 三元组

1. 赋值/初始化

- p = make_pair(10, "yxc")
- p = {10, "yxc"}

1. 取到元素

- p.first
- p.second

##### 案例：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    //初始化
    pair<int, string>p;
    p = make_pair(10, "yxc");
    p = {20, "abc"};
    //三种属性
    pair<int, pair<int, int>>q;
    return 0;
}
```

#### String，字符串

1.常用函数

- 返回字符串长度：size()/length()
- 插入：str.insert(str.begin(), 'a')
- 返回子串：str.substr(起始坐标，(长度))
- 字符串添加元素：str.push_back('a')
- 字符串删除末尾元素：str.pop_back('a')
- 删除元素 str.substr(0, str.length() - 1);
- 删除元素 str.erase(str.end() - 1);
- 返回字符串所在字符数组的起始地址： c_str()
- 为空/清空 empty()/clear()

2.整型和字符串的相互转换

- 整型转字符串
- to_string(i)
- 字符串转整型
- int a=atoi(s.c_str());
- int b=stoi(s);

##### 案例：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    string a = "yxc";
    a += "def";
    a += 'C';
    cout << a << endl;
    //常用函数
    cout << a.substr(1, 10) << endl;//输出到最后一个字母为止
    //返回从一开始的子串
    cout << a.substr(1) << endl;
    //a存储地址的字符地址
    printf("%s\n", a.c_str());
    return 0;
}
```

#### queuee，队列

- 没有clear(), 清空：q = queue<int>()
- size()
- empty()
- push() 向队尾插入一个元素
- front() 返回队头元素
- back() 返回队尾元素
- pop() 弹出队头元素

##### 案例：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
int main() {
    queue<int> q;
    //清空queue：自行实现 
    q = queue<int>();
    return 0;
}
```

#### priority_queue，优先队列，默认是大根堆

- 没有clear()
- size()
- empty()
- push() 插入一个元素
- top() 返回堆顶元素
- pop() 弹出堆顶元素
- 大根堆插入-x就是小根堆
- 定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

##### 案例：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
int main() {
    priority_queue<int> heap1;//默认大跟堆
    //小根堆从小到大排序：负数
    int x;
    heap1.push(-x);
    //定义时直接定义小根堆：多定义两个参数
    priority_queue<int, vector<int>, greater<int>> heap2;
    return 0;
}
```

#### stack，栈 （加强版的vector O(1)）

- size()

- empty()
- push()  向栈顶插入一个元素
- top()  返回栈顶元素
- pop()  弹出栈顶元素

##### 案例：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>
using namespace std;
int main() {
    deque<int> q;
    //清空
    q.clear();
    return 0;
}
```

#### deque，双端队列（效率慢）

- size()
- empty()
- push() 向队尾插入一个元素
- front() 返回队头元素
- back() 返回队尾元素
- pop() 弹出队头元素

#### set（没有重复元素：忽略）

- set遍历

1. set<int>::iterator it;
2. for(it=notAppearSet.begin ();it!=notAppearSet.end ();it++) cout << *it;

#### multiset（可以有重复元素）

#### map

- map<int, int> loc;
- map a["yxc"] = 1
- 获取键、值 for(auto x : f1) x.first,x.second
- 查找：

s.find() 查找一个元素，如果容器中不存在该元素，返回值等于s.end()

if(numSet.find(findNum)!=numSet.end()
代表找到了

#### set, map, multiset, multimap（基于平衡二叉树（红黑树），动态维护有序序列）

- size()
- empty()
- clear()
- begin()/end()
- ++, -- 返回前驱（前一个数）和后继（后一个数），时间复杂度 O(logn)
- set/multiset
- insert() 插入一个数
- find() 查找一个数
- count() 返回某一个数的个数
- erase()

(1) 输入是一个数x，删除所有x O(k + logn)

(2) 输入一个迭代器，删除这个迭代器

- lower_bound()/upper_bound()

lower_bound(x) 返回大于等于x的最小的数的迭代器

upper_bound(x) 返回大于x的最小的数的迭代器

- map/multimap

insert() 插入的数是一个pair

erase() 输入的参数是pair或者迭代器

find()

[] 注意multimap不支持此操作。 时间复杂度是 O(logn)

lower_bound()/upper_bound()

#### unordered_set,unordered_multiset,unordered_map,unordered_multimap，哈希表

- 和上面类似，增删改查的时间复杂度是 O(1)
- 不支持 lower_bound()/upper_bound()， 迭代器的++，--

#### bitset，圧位

- bitset<10000> s;

- ~, &, |, ^

- > > , <<

- ==, !=

- []

- count() 返回有多少个1

- any() 判断是否至少有一个1

- none() 判断是否全为0

- set() 把所有位置成1

- set(k, v) 将第k位变成v

- reset() 把所有位变成0

- flip() 等价于~

- flip(k) 把第k位取反

#### auto 自动推断类型

- auto x = max_element(a.begin() + i, a.end());用的时候*x



**Day26.(2023.3.5)**

## 搜索与图论

### DFS与BFS

>概述
>DFS：深度优先搜索（Depth-First-Search）
>
>BFS：宽度优先搜索（Breadth-First-Search）
>
>DFS和BFS的对比
>
>- DFS使用栈（stack）来实现，BFS使用队列（queue）来实现
>- DFS所需要的空间是树的高度h，而BFS需要的空间是2h （DFS的空间复杂度较低）
>- DFS不具有最短路的特性，BFS具有最短路的特性
>
>通常来说，求“最短”的操作，都可以用BFS来做，而其他一些奇怪的操作，或者对空间复杂度要求比较高，则用DFS来做

#### 深度优先搜索 DFS

DFS 中重要的两个概念：回溯、剪枝

- **回溯**：回溯的时候，一定要记得恢复现场
- **剪枝**：提前判断某个分支一定不合法，直接剪掉该分支

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10;
int n;
int path[N];//记录所有的搜索路径
bool st[N];//记录这些点有没有被用过，1表示是，0表示否
void dfs(int u) {// 第u层
    if(u == n) {//从0开始作为第一层，当搜索完最后一层，就输出这条路径并结束递归
        for(int i=0;i<n;i++) {
            printf("%d ",path[i]);
        }
        puts("");
        return;
    }
    for(int i=1;i<=n;i++) {
        if(!st[i]) {
            path[u] = i;//写入路径记录
            st[i] = true;//更新状态为已使用
            dfs(u+1);//给下一层找数
            //----------------------------------下一层递归结束，此时该恢复状态了
            st[i] = false;//更新状态为未使用
            path[u] = 0;//清空该层路径记录
        }
    }
}
int main() {
    cin>>n;
    dfs(0);
    return 0;
}
```

BFS 一般和最短路径有关系，DFS 没有

> 回溯注意点：记得恢复现场

##### DFS模板：

```cpp
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过
 
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

##### ACWING:842

全排列的 DFS 过程：

<img src="https://img-blog.csdnimg.cn/img_convert/adc122141e7028b14a2bf8b6636a3ccd.png" style="zoom:60%;" />

```cpp
/*842.排列数字
给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。
现在，请你按照字典序将所有的排列方法输出。
输入格式
共一行，包含一个整数 n。
输出格式
按字典序输出所有排列方案，每个方案占一行。
数据范围
1≤n≤7
输入样例：
3
输出样例：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
*/
#include <iostream>
using namespace std;
const int N = 10;
int n, path[N];//存储当前已经插入的数字
bool s[N];//标记数组，标记下标为i的数字是否用过
void dfs(int cur) {
    if(cur > n) {//如果n个位置都已经插入完成，此时cur为n+1，因为数组下标从1开始
        for(int i = 1; i <= n; i++)  printf("%d ",path[i]);
        puts("");
        return;
    }
    //遍历所有数字，找出还没使用过的数字
    for(int i = 1; i <= n; i++) {
        if(!s[i]) {//如果第i个数字未使用过
            s[i] = true;//标记第i个数字已经使用
            path[cur] = i;//把第i个数字插入到数字当前数组中
            dfs(cur+1);//继续深搜能够插入下一个位置的数字
            s[i] = false;//恢复现场，将i标记成还未使用过
        }
    }
}
int main() {
    cin >> n;
    dfs(1);
    return 0;
}
```

##### ACWING:843

###### 暴力枚举棋盘中的每一个元素

```cpp
//超时
#include<iostream>
using namespace std;
const int N = 20;
int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];//row-行
//在算法中，通常纵轴表示x，横轴表示y
void dfs(int x, int y, int s) {//s代表当前皇后的数量，x,y代表坐标
    if(y == n) y = 0, x ++;//即在每一行遍历格子越界时，要转到下一行的第一个格子
    if(x == n) {
        if(s == n) {//说明找到了解，可以输出结果了
            for(int i = 0; i < n; i++)  cout << g[i] << endl;
            cout << endl;
            return;
        }
    }
    //对每一个格子，有放皇后和不放皇后两种选择
    //1.放皇后
    if(!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]) {
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1);
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        g[x][y] = '.';
    }
    //2.不放皇后
    dfs(x, y + 1, s);
}
 
int main() {
    cin >> n;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            g[i][j] = '.';
    dfs(0, 0, 0);
    return 0;
}
```

###### 排列数字思想

（搜索顺序一）由于每一行每一列上都只能有一个皇后，我们可以按行枚举，判断皇后应该放在哪一列上。且根据任意两个皇后都不能在同一条对角线上“剪枝”。

（搜索顺序二）我们按照一行一行的顺序，逐个枚举每一个格子。根据限定条件“任意两个皇后都不能处于同一行、同一列或同一斜线上”上判断是否应该放皇后，最后皇后的数量等于n说明我们已经找到了结果，输出即可。

1. 对角线、反对角线的表示，是用截距`b`代表。`b`的代数表达式如下图所示：

   <img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230305160314142.png" alt="" style="zoom:50%;" />

2. `g[N][N]`为char型的二维数组，但是输出确实`g[i]`的一维数组形式，这是因为输出`g[i]`详单与`char*`，也就是按行输出字符串。（这里的输出很取巧，因为 g[i][j] 是一个全局变量，因此初始值全为 0，而字符串的结束符为 0, 所以在最后输出的时候只用了一层循环）

3. 算法一的时间复杂度为n*n!，算法二的时间复杂度为2^n^2

故算法二的时间复杂度高于算法一，算法二会超时！

```cpp
/*843.n-皇后问题
n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
现在给定整数 n，请你输出所有的满足条件的棋子摆法。
输入格式：
共一行，包含整数 n。
输出格式：
每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。
其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。
每个方案输出完成后，输出一个空行。
注意：行末不能有多余空格。
输出方案的顺序任意，只要不重复且没有遗漏即可。
数据范围：
1≤n≤9
输入样例：
4
输出样例：
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
二、算法基本思想
DFS（深度优先搜索）
（搜索顺序一）由于每一行每一列上都只能有一个皇后，我们可以按行枚举，判断皇后应该放在哪一列上。且根据任意两个皇后都不能在同一条对角线上“剪枝”。
（搜索顺序二）我们按照一行一行的顺序，逐个枚举每一个格子。根据限定条件“任意两个皇后都不能处于同一行、同一列或同一斜线上”上判断是否应该放皇后，最后皇后的数量等于n说明我们已经找到了结果，输出即可。
三、步骤
1.首先在所有的棋盘上都填上“ . ”
2.按行开始枚举，判断皇后应该放在哪一列（核心代码）
（1）当算法进行到第n行时，代表n个皇后都已经放置完毕，可以直接呼出结果了
（2）当算法没有进行到第n行时（设为u)，利用for循环从第1列开始遍历，如果第i列没有放皇后，且其所处的正对角线和反对角线也都没有放置皇后，说明该位置可以
放皇后；
    然后标记这个位置所在的列、对角线和反对角线为true，即在同一列、同一对角线和同一反对角线的位置不可以再放皇后；
    接着调用dfs函数，进行到第 u + 1行，重复此操作；
    当dfs函数结束以后，一定要记得恢复上一层的状态（即列、对角线反对角线都恢复为未使用的状态）。这是dfs的回溯操作。
3.输出结果
*/
```

###### 按行枚举

```cpp
/*843.n-皇后问题
n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
现在给定整数 n，请你输出所有的满足条件的棋子摆法。
输入格式：
共一行，包含整数 n。
输出格式：
每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。
其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。
每个方案输出完成后，输出一个空行。
注意：行末不能有多余空格。
输出方案的顺序任意，只要不重复且没有遗漏即可。
数据范围：
1≤n≤9
输入样例：
4
输出样例：
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
二、算法基本思想
DFS（深度优先搜索）
（搜索顺序一）由于每一行每一列上都只能有一个皇后，我们可以按行枚举，判断皇后应该放在哪一列上。且根据任意两个皇后都不能在同一条对角线上“剪枝”。
（搜索顺序二）按照一行一行的顺序，逐个枚举每一个格子。根据限定条件“任意两个皇后都不能处于同一行、同一列或同一斜线上”上判断是否应该放皇后，最后皇后的数量等于n说明我们已经找到了结果，输出即可。
三、步骤
1.首先在所有的棋盘上都填上“ . ”
2.按行开始枚举，判断皇后应该放在哪一列（核心代码）
    （1）当算法进行到第n行时，代表n个皇后都已经放置完毕，可以直接输出结果了
    （2）当算法没有进行到第n行时（设为u)，利用for循环从第1列开始遍历，如果第i列没有放皇后，且其所处的正对角线和反对角线也都没有放置皇后，说明该位置可以放皇后；
        然后标记这个位置所在的列、对角线和反对角线为true，即在同一列、同一对角线和同一反对角线的位置不可以再放皇后；
        接着调用dfs函数，进行到第 u + 1行，重复此操作；
        当dfs函数结束以后，一定要记得恢复上一层的状态（即列、对角线反对角线都恢复为未使用的状态）。这是dfs的回溯操作。
3.输出结果
*/
#include <iostream>
using namespace std;
const int N = 20;
int n;
char g[N][N]; // 存储路径
// bool 数组用来判断搜索的下一个位置是否可行
// col 列, dg 对角线(左上->右下), udg 反对角线(左下->右上)
bool col[N], dg[N], udg[N];
// 按行搜索
void dfs(int u) {
    if (u == n) {
        for (int i = 0; i < n; i ++) puts(g[i]);
        puts("");
        return;
    }
    // 枚举 u 这一行，搜索合法的列
    int x = u;
    for (int y = 0; y < n; y++) {
        // 剪枝(对于不满足要求的点，不再继续往下搜索)  
        if (!col[y] && !dg[y - x + n] && !udg[y + x]) {
            // 标记已访问，并加入路径
            col[y] = dg[y - x + n] = udg[y + x] = true;
            g[u][y] = 'Q';
            // 向下搜索
            dfs(u + 1);
            // 回溯
            g[u][y] = '.';
            col[y] = dg[y - x + n] = udg[y + x] = false;  
        }
    }
}
int main() {
    cin >> n;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < n; j ++)
            g[i][j] = '.';
    dfs(0);
    return 0;
}
```

###### 按格枚举

```cpp
#include <iostream>
using namespace std;
const int N = 20;
int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];
// 比较原始的 dfs 搜索，每一格都搜，s 表示皇后数量
void dfs(int x, int y, int s) {
    // 换行
    if (y == n) y = 0, x ++;
    if (x == n) {
        // 摆好了 n 个皇后
        if (s == n) {
            for (int i = 0; i < n; i ++)  puts(g[i]);
            puts("");
        }
        return;
    }
    // 不放皇后
    dfs(x, y + 1, s);
    // 放皇后
    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]) {
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1); // 递归下一层
        g[x][y] = '.';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
    }
}
int main() {
    cin >> n;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < n; j ++)
            g[i][j] = '.';
    dfs(0, 0, 0);
    return 0;
}
```



**Day27.(2023.3.7)**

#### 宽度优先搜索 BFS

只有当所有边的权重都是 1 时，才可以用 BFS 求最短路。

##### BPS模板：

```cpp
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);
 
while (q.size())
{
    int t = q.front();
    q.pop();
 
    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

##### ACWING:844

```cpp
/*844.走迷宫
给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。
最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。
请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。
数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。
输入格式
第一行包含两个整数 n 和 m。
接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。
输出格式
输出一个整数，表示从左上角移动至右下角的最少移动次数。
数据范围
1≤n,m≤100
输入样例：
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
输出样例：
8*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int ,int > PII;
const int N = 110;
int g[N][N];//地图 
int f[N][N];//距离 
int n, m;
//0是没走过，1走过 
void bfs(int a, int b) {
	//队列判断 
	queue<PII> q;
	q.push({a, b});
	while(!q.empty()) {
		PII start = q.front();
		q.pop();
		//走过之后直接由0变为1 
		g[start.first][start.second] = 1;
	    //四个方向（上下右左） 
		int dx[4] = {0, 1, 0, -1};
		int dy[4] = {-1, 0, 1, 0};
		for(int i = 0; i < 4; i ++) {
			//开始移动 
			int x = start.first + dx[i];
			int y = start.second + dy[i];
			if(g[x][y] == 0){
				g[x][y] = 1;
				f[x][y] = f[start.first][start.second] + 1;
				q.push({x, y});
			}
		}
	}
	cout << f[n][m];
}
int main() { 
    //g数组全部初始化为1，不用判断越界，走不出去了 
	memset(g, 1, sizeof(g));
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			cin >> g[i][j];
		}
	}
	bfs(1, 1);
	return 0;
}
```



**Day28.(2023.3.7)**

### 树和图的存储

首先，树是一种特殊的图（无环连通图）。所以，这里只说图的存储即可。

首先，图分为2种，有向图和无向图。

有向图中2个点之间的边是有方向的，比如a -> b，则只能从a点走到b点，无法从b点走到a点。

无向图中2个点之间的边是没有方向的，比如a - b，则可以从a走到b，也可以从b走到a。

通常，我们可以将无向图看成有向图。比如上面，对a到b之间的边，我们可以建立两条边，分别是a到b的，和b到a的。

```cpp
有向图：（两个点之间有固定的方向）
a ---> b

无向图：（实际上就是每个方向都能走）
a ---> b
b ---> a
```

所以，我们只需要考虑，有向图如何存储，即可。通常有2种存储方式

- 邻接矩阵

  用一个二维数组来存，比如g[a,b]存储的就是a到b的边。邻接矩阵无法存储重复边，比如a到b之间有2条边，则存不了。（用的较少，因为这种方式比较浪费空间，对于有n个点的图，需要n^2的空间，这种存储方式适合存储稠密图）

- 邻接表

  使用单链表来存。对于有n个点的图，我们开n个单链表，每个节点一个单链表。单链表上存的是该节点的邻接点（用的较多）

树和图遍历有2种方式，深度优先遍历和宽度优先遍历。

我们只需要考虑有向图的遍历即可。

<img src="https://img-blog.csdnimg.cn/img_convert/f678307f928357afb95047a03a71c78c.png" style="zoom:50%;" />

>规定：n - 图的点数，m - 图的边数

##### 树与图的遍历模板：

```cpp
时间复杂度 O(n+m), n表示点数，m表示边数

(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心

int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次

queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

树与图的存储模板：

```cpp
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[a][b] 存储边a->b

(2) 邻接表：

// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点

int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

##### 图的邻接表存储：适用于稀疏图（ m 和 n 是一个量级）

- 无权图

  ```cpp
  int h[N]; // 链表头
  int e[M]; // 节点的值
  int ne[M]; // 下一个节点
  int idx; // 当前节点的索引
  
  // 插入一条 a 指向 b 的边
  // 在 a 对应的单链表中插入一个节点 b
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx++;
  }
  ```

- 有权图

  ```cpp
  // 对于有权图，需要一个 w[] 存储权值
  int h[N], e[M], ne[M], w[M], idx;
  
  void add(int a, int b, int c)
  {
  	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
  }
  ```

##### 图的邻接矩阵存储：适用于稠密图（m 和 n^2 一个量级）

```cpp
// g[i][j] = k 表示 i 指向 j 边长为 k
int g[N][N];

void add(int a, int b, int c)
{
	g[a][b] = min(g[a][b], c); // 处理重边，只需要记录最短的边
}
```

##### Bellman Ford 算法中使用的结构体进行存储边：

```cpp
// a 指向 b 权重为 w 的边
struct Edge {
	int a, b, w;
} edges[M];
```

#### 树和图的深度优先遍历：拓扑排序

> 由于遍历时，每个点最多只会被遍历一次，所以深度优先遍历的时间复杂度是O(n+m)，n是节点数，m是边数

##### DFS 模板：

```cpp
void dfs(int u) 
{
    
    st[u] = true; // 标记已访问
    int sum = 1, res = 0;
	for (int i = h[u]; i != -1; i = ne[i])
	{
    	int j = e[i];
    	if (!st[j]) dfs(j);
	}
}
```
##### 树的重心:（深度优先遍历，可以算出每个子树所包含的节点个数）

##### ACWING:846

```cpp
/*846.树的重心
给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。
请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。
重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。
输入格式
第一行包含整数n，表示树的结点数。
接下来n-1行，每行包含两个整数a和b，表示点a和点b之前存在一条边。
输出格式
输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。
数据范围
1≤n≤10^5
输入样例
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
输出样例：
4*/
/*树作为一种递归的数据结构，树的问题十有八九也是用递归方式来解决的。从某种意义上说，dfs与递归的界限并没有那么明显，所以在对树进行深度优先遍历时，往往能够顺便求解很多问题。
首先，分析下本题的存储，普通的树，是特殊的图，而且是稀疏图，所以使用邻接表来存储。邻接表的实现可以采用vector加上结构体的形式，较为简洁，但是用数组实现效率更高。我们用h[i]表示编号为i节点的第一条边的序号，边的编号用idx表示，用e[idx]数组存储第idx条边指向节点的编号，用ne[i]表示下一条边的序号。下面实现给从节点a到b添加一条边的操作。
void add(int a,int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
用文字描述下加边的过程就是，e[idx]=b;//第idx条边指向b节点，ne[idx]=h[a];//第idx条边下一条边的序号是a节点原来第一条边的序号，h[a]=idx++;//a节点的第一条边的序号为idx（也就是a->b这条边）,如果需要加上权重的话，在之前加上w[idx]=c;即可。上面的代码也就是单链表的头插法的操作，为啥要用头插法，如果采取尾插法的话还要存储a节点指向最后一条边的序号，比较麻烦。对于树，直接当成无向图处理，每条边双向添加即可。
要想找到树的重心，需要知道去掉某节点后剩下连通块中节点的数量，对于某个节点u，以u为根节点的子树的节点总数为x，则其父节点（若存在）所在连通块节点的数目为n-x。要求以某节点为根节点子树的节点的个数，只需要递归的求以其孩子节点为根节点子树的总和即可。设int dfs(int u)这个函数能够实现该功能，则想要统计u所有子树节点之和，只需要int sum = 0；u的孩子节点比如有a，b，sum + dfs(a)+dfs(b) + 1即是u所在子树节点的总和了，同时，还可以求各个连通块节点的最大值，找到树的重心。*/
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn = 100005, maxm = 2 * maxn;
int n, h[maxn], e[maxm], ne[maxm], idx;
int ans = maxn;
bool st[maxn];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
int dfs(int u) {
    st[u] = true;//已经访问过，防止重复遍历父节点
    int size = 0, sum = 0;
    for(int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if(st[j])   continue;//不用遍历父节点
        int s = dfs(j);
        size = max(size, s);//更新连通块的最值
        sum += s;//加上孩子节点的个数
    }
    size = max(size, n - sum - 1);//再次与父节点所在的连通块比较最值
    ans = min(ans, size);//找到最小连通块个数
    return sum + 1;
}
int main() {
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 0; i < n - 1; i ++) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```



### 树和图的宽度优先遍历

##### BFS模板

```cpp
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (!q.empty())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点 j 已经被遍历过
            q.push(j);
        }
    }
}
```

##### ACWING:847

```cpp
/*847.图中点的层次
给定一个n个点m条边的有向图，图中可能存在重边和自环。
所有边的长度都是1，点的编号为1~n。
请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。
输入格式
第一行包含两个整数n和m。
接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。
输出格式
输出一个整数，表示1号点到n号点的最短距离。
数据范围
1≤n,m≤10^5
样例
输入样例：
4 5
1 2
2 3
3 4
1 3
1 4
输出样例：
1*/
/*用单链表储存树和图时，从每一个节点的头指针只能储存当前节点能到达的下一层的节点
宽度优先遍历没有进行递归所以每一次搜索都是以头结点指向的位置
例如 1->2 1->3 1->5 2->8 3->6 3->7
即
    h[1]->5->3->2->-1;
    h[2]->8->-1;
    h[3]->7->6->-1;
宽度遍历和深度遍历的区别就是：深度优先遍历每搜一次就进入递归调用自身，使得搜索的节点的头指针发生变化即变成了指向当前节点的头指针，然后就变成了搜索此节点能到达的下一层。
宽度优先遍历没有进行递归也就是一直搜索当前节点能到达的下一层节点直到节点搜索完时再搜索下一节点 。*/
#include <iostream>
#include <cstring>
using namespace std;
const int N = 100010;
int n, tt = 0, hh = 0, m, idx = 0;//头指针尾指针和插入的第几个数 
int e[N], ne[N], q[N];
int d[N], h[N];//存储每个节点距离起点的距离 d[1] = 0
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;//插入操作 
}
void bfs() {
    q[0] = 1;
    memset(d, -1, sizeof(d));
    d[1] = 0;
    while(hh <= tt) {
        int t = q[hh ++];
        for(int i = h[t]; i != -1; i = ne[i]) {//对每一层的节点进行遍历 
            int j = e[i];
            if(d[j] == -1) {//如果没有被搜索到
                d[j] = d[t] + 1;//当前节点的根节点的距离加1 
                q[++ tt] = j;//插入队列中 
            }
        }
    }
    cout << d[n] << endl;
}
int main() {
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 1; i <= m; i ++) {
        int a, b;
        cin >> a >> b;
        add(a ,b);
    }
    bfs();
    return 0;
}
```

**Day29.(2023.3.8)**

### 拓扑排序

一个有向**无环图**，一定至少存在一个入度为 0 的点，一定存在拓扑序列。

> 可利用反证法很快的得到结论，如果每个点都前驱节点，那么这个图将无穷无尽。

入度为 0 表示没有任何一个点要求在前面，所有入度为 0 的点都可以排在前面位置。

拓扑排序的思路：

- 将入度为 0 的点入队，再删去该点指向的点的所有边
- 若删去边后又有入度为 0 的点，再将这些点入队
- 重复上述过程，直到队列为空
- 最后队列中若入队过 n 个点，则可以实现拓扑序

###### 拓扑排序模板：

```cpp
时间复杂度 O(n+m), n表示点数，m表示边数

bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

#### 有向图的拓扑排列

<img src="https://img-blog.csdnimg.cn/4a9adc8dfb6d40f6831f0ac770c9c132.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmVmdV9seWg=,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:50%;" />

##### ACWING:848

```cpp
/*848.有向图的拓扑排序（序列）
给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。
请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。
若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。
输入格式
第一行包含两个整数 n和 m。
接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y的有向边 (x,y)。
输出格式
共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。
否则输出 −1。
数据范围
1≤n, m≤10^5
输入样例：
3 3
1 2
2 3
1 3
输出样例：
1 2 3
*/
/*这里考虑入度(几条边指向自己)，出度(几条边指出)。
首先思考，如果无环图即满足拓扑排序，是否可以将该节点的所有 出边 删去，结果使得每个节点的入度是0，满足入度是0，则将其存储起来。
如果存在环，一定存环上的点入度不是0.
所以可以将结点的出边删除，下个节点的入度减减。*/
#include <iostream>
#include <cstring>
using namespace std;
const int N = 100010;
int e[N], ne[N], h[N], idx;//用于创建邻接表
int n, m;
int d[N];//记录每个节点的入度
int q[N];//记录拓扑序列
void add(int a,int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
bool topsort() {
    int hh = 0, tt = -1;//因为此时没有放入任何节点所以tt=-1
    for(int i = 1; i <= n; i ++)//将所有入度为0的点放入队列
        if(d[i] == 0)   q[++ tt] = i;
    while(hh <= tt) {
        int t = q[hh ++];//取出队头元素
        for(int i = h[t]; i != -1; i = ne[i]) {//找队头元素的出边j
            int j = e[i];
            d[j] --;//j的入度--
            if(d[j] == 0)   q[++ tt] = j;//j的入度--为0时加入队列
        }
    }
    return tt == n - 1; //当tt=n-1时，所有点都入队了表示没有环，返回true
}
int main() {
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 0; i < m; i ++) {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;//节点b的入度+1
        //不要对d数组进行初始化，因为d是全局变量，会自动初始化为0
    }
    if(topsort()) {//有拓扑序列则输出顺序
        for(int i = 0; i < n; i ++)
            cout << q[i] << " ";
    } else {
        puts("-1");
    }
    return 0;
}
```

入队的时候是q[++tt]，先移动下标到下一位置即++tt，再对该位置赋值
出队(队头后移)是q[hh++]，先取出队头元素q[hh]，再移动队头下标h++

**Day29.(2023.3.8)**

### 最短路

> 图论中的 **源点 == 起点**，**汇点 == 终点** 

规定：n - 图的点数，m - 图的边数

<img src="%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20230308211100542.png" style="zoom:50%;" />

**单源**，只有一个起点的最短路。
**多源**，多个不同起点到其他点的最短路。

**稠密图**，指边数很多，m 和 n^2 是一个量级。
**稀疏图**，指边数不多，m 和 n 是一个量级。

#### Dijkstra

##### 朴素 Dijkstra

> Dijkstra 基于贪心，当有负权边时，局部最优不一定全局最优。

###### 朴素dijkstra算法模板：

```cpp
时间复杂是 O(n^2+m), n表示点数，m表示边数

int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

###### ACWING:849

整体思路：进行 n - 1 次迭代去确定每个点到起点的最小值。

1. 初始化距离为无限大，源点到源点距离为 0
2. 进行 n 次迭代：
   1. 找到当前没有确定最短路的点中，距离源点最近的点 t
   2. 使用 t 更新其他点的距离（比较 1–> j 和 1–>t–> j 的距离）

时间复杂度分析：

- 寻找路径最短的点：O(n^2)

图解：[AcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing](https://www.acwing.com/solution/content/38318/)

使用邻接矩阵的写法：

```cpp
/*849.Dijkstra求最短路
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。
请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。
输入格式
第一行包含整数 n 和 m。
接下来 m 行每行包含三个整数 x, y, z，表示存在一条从点 x 到点 y 的有向边，边长为 z。
输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。
如果路径不存在，则输出 −1。
数据范围
1≤n≤500, 1≤m≤10^5
图中涉及边长均不超过 10000。
输入样例：
3 3
1 2 2
2 3 1
1 3 4
输出样例：
3*/
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510;
int g[N][N]; // 邻接矩阵（稠密图）
int dist[N]; // 到源点的距离
bool st[N]; // 记录是否已经找到最短路
int n, m; // n 个点, m 条边
int dijkstra() {
    // 距离初始化成无穷大
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0; // 1 号点距离为 0
    for (int i = 0; i < n; i ++){
	    // 在没有确定最短路的点中，距离源点最近的点
        int t = -1;
        for (int j = 1; j <= n; j ++)
            // 当前点未确定最短路 && 当前路不是最短的
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true; // 标记已经确定最短路
        // 使用 t 更新其他点距离
        // 遍历所有 t 可以达到的点 jd
        for (int j = 1; j <= n; j ++)
            // 比较 1--> j 和 1--> t --> j 的距离
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if (dist[n] == 0x3f3f3f3f)  return -1;
    return dist[n];
}
int main() {
    scanf("%d%d", &n, &m);
    // 默认边长初始化成无穷大
    memset(g, 0x3f, sizeof g);
    while (m --){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        // 处理重边，只需要记录最短的边
        g[a][b] = min(g[a][b], c);
    }
    printf("%d\n", dijkstra());
    return 0;
}
```

邻接表的写法：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1e6 + 10;
int h[N], w[N], e[N], ne[N], idx; // 邻接表
int dist[N]; // 到源点的距离
bool st[N]; // 是否已经确认最短路
int n, m;
void add (int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < n; i ++) {
        int t = -1;
        // 找到未确定最短路的点中，距离源点最近的点 t
        for (int j = 1; j <= n; j ++)
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        st[t] = true;
        // 使用 t 更新邻点的最短路径
        for (int j = h[t]; j != -1; j = ne[j]) {
            int k = e[j]; // 遍历 t 的邻点
            dist[k] = min(dist[k], dist[t] + w[j]);     
        }
    }
    if (dist[n] == 0x3f3f3f3f)  return -1;
    return dist[n];
}
int main() {
    scanf("%d%d", &n, &m);
    // 默认边长初始化成无穷大
    memset(h, -1, sizeof h);
    while (m --) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        // 处理重边，只需要记录最短的边
        add(a, b, c);
    }
    printf("%d\n", dijkstra());
    return 0;
}
```

**Day30.(2023.3.9)**

##### 堆优化的 Dijkstra

堆优化版的 Dijkstra 使用**最小堆**优化朴素版中的寻找距离最短的点。

> C++ 中的 pair 二元组默认支持比较，以 first 为第一关键字，second 为第二关键字，进行字典序比较。

堆中存储的是一个 二元组`{距离, 节点编号}`，从而优化**找出距离最短的点**这个过程。

时间复杂度：O(mlogn)，遍历所有点的出边，相当于遍历所有边，所以是 m 次

1. 一号点的距离初始化为零，其他点初始化成无穷大。

2. 将一号点放入堆中。

3. 不断循环，直到堆空。每一次循环中执行的操作为：

   弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。

   用该点更新临界点的距离，若更新成功就加入到堆中。

   时间复杂度分析

   ​	寻找路径最短的点：O(n)

   ​	加入集合S：O(n)

   ​	更新距离：O(mlogn)

###### 堆优化版dijkstra算法模板：

```cpp
时间复杂度 O(mlogn)，n表示点数，m表示边数

typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

###### ACWING:850

邻接表：这题最合适的解法

```cpp
/*850.Dijkstra求最短路II
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。
请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。
输入格式
第一行包含整数 n 和 m。
接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。
输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。
如果路径不存在，则输出 −1。
数据范围
1≤n,m≤1.5×10^5,
图中涉及边长均不小于 0，且不超过 10000。
数据保证：如果最短路存在，则最短路的长度不超过 109。
输入样例：
3 3
1 2 2
2 3 1
1 3 4
输出样例：
3*/
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int N = 1e6 + 10;
typedef pair<int, int> PII; // 堆里存储 { 距离, 节点编号 }
int h[N], w[N], e[N], ne[N], idx; // 邻接表（稀疏图）
int dist[N]; // 距离源点的距离
bool st[N]; // 是否已经找到最短路
int n, m;
// 添加 a 指向 b 边长为 c 的边
void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}
int dijkstra() {
    memset(dist, 0x3f, sizeof dist); // 距离初始化为无穷大
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap; // 小根堆
    heap.push({0, 1}); // 1 号点距离源点距离为 1
    while (heap.size()) {
        PII t = heap.top(); // 距离源点最近的点
        heap.pop();
        int ver = t.second; // 节点编号
        // int distance = t.first; // 源点距离 ver 的距离
        if (st[ver])    continue; // 如果距离已经确定，则跳过该点
        // 更新 ver 所指向的节点距离       
        st[ver] = true;
        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
			// 比较 1-->j 和 1-->ver-->j 的距离
            if (dist[j] > dist[ver] + w[i]) {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j}); // 距离变小，则入堆
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)  return -1;
    return dist[n];
}
int main() {
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while (m -- ) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c); // 邻接表不需要考虑重边
    }
    cout << dijkstra() << endl;
    return 0;
}
```

邻接矩阵：内存开辟过大，会报错

```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;
const int N = 5500;
typedef pair<int, int> PII; // {距离, 节点编号}
int g[N][N]; // 邻接矩阵
int dist[N], st[N];
int n, m;
int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap; // 小根堆
    heap.push({0, 1}); 
    while (heap.size()) {
        PII t = heap.top();
        heap.pop();
        int ver = t.second; // 距离源点最近的点
        if (st[ver])    continue;
        // 利用 t 更新它的邻点
        st[ver] = true; 
        for (int i = 1; i <= n; i ++) {
            // 比较 1->i 和 1->ver->i
            if (dist[i] > dist[ver] + g[ver][i]) {
                dist[i] = dist[ver] + g[ver][i];
                heap.push({dist[i], i});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)  return -1;
    else return dist[n];
}
int main() {
    memset(g, 0x3f, sizeof g);
    cin >> n >> m;
    while (m -- ) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = min(g[a][b], c); // 处理重边
    }
    cout << dijkstra() << endl;
    return 0;
}
```

**Day31.(2023.3.10)**

#### Bellman-Ford

> bellman-ford 算法擅长解决**有边数限制的最短路问题**

步骤：

```cpp
// back 数组是上一次迭代后 dist 数组的备份。
for n 次
	for 所有边 a,b,w (松弛操作)
		dist[b] = min(dist[b], back[a] + w)时间复杂度：O(nm)
```

为什么需要 back 数组？

- 为了避免如下的串联情况， 在边数限制为一条的情况下，节点 3 的距离应该是 3，但是由于串联情况，利用本轮更新的节点 2 更新了节点 3 的距离，所以现在节点 3 的距离是 2。

  ![](https://img-blog.csdnimg.cn/img_convert/064bd9839ee87d02630ac9602089b68c.png)

- 正确做法是用上轮节点 2 更新的距离 – 无穷大，来更新节点 3， 再取最小值，所以节点 3 离起点的距离是 3。

  ![](https://img-blog.csdnimg.cn/img_convert/93b404309c46692e0afde89b46ab6e7a.png)


可以定义一个类，或者C++里面的结构体，存储a，b，w。表示存在一条边a

点指向b点，权重为w）。则遍历所有边时，只要遍历全部的结构体数组即可

循环的次数的含义：假设循环了k次，则表示，从起点，经过不超过k条边，走到每个点的最短距离。

该算法能够保证，在循环n次后，对所有的边(a, b, w)，都满足d[b] <= d[a] + w。这个不等式被称为三角不等式。上面的更新操作称为松弛操作。

该算法适用于有负权边的情况。

注意：如果有负权回路的话，最短路就不一定存在了。（注意是不一定存在）。当这个负权回路处于1号点到n号点的路径上，则每沿负权回路走一圈，距离都会减少，则可以无限走下去，1到n的距离就变得无限小（负无穷），此时1号点到n号点的最短距离就不存在。而如果负权回路不在1号点到n号点的路径上，则1到n的最短距离仍然存在。

该算法可以求出来，图中是否存在负权回路。如果迭代到第n次，还会进行更新，则说明存在一条最短路，路径上有n条边，n条边则需要n + 1个点，而由于图中一共只有n个点，所以这n + 1个点中一定有2个点是同一个点，则说明这条路径上有环；有环，并且此次进行了更新，说明这个环的权重是负的（只有更新后总的距离变得更小，才会执行更新）。

但求解负权回路，通常用SPFA算法，而不用Bellman-Ford算法，因为前者的时间复杂度更低。

由于循环了n次，每次遍历所有边（m条边）。故Bellman-Ford算法的时间复杂度是O(n×m)，nn 表示点数，mm 表示边数
注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。

##### Bellman-Ford算法模板：

**本质思想**：尝试能否利用 源点 → a → b 来减少 源点 → b 的距离

```cpp
时间复杂度 O(nm), n表示点数，m表示边数
注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。

int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
	// 进行k次迭代，表示最多经过k条边可以到达的最短路
    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        // 每次循环所有边,格式为(a, b, w)，即a → b，权重是w
		// 因此这里所有边的遍历方式不一定使用邻接表，可以用傻瓜式的结构体数组存储
		// dist[i] 表示从源点到i的距离
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w; // 松弛操作
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

思路：连续进行松弛，在每次松弛时把每条边更新一下，若在 n - 1 次松弛后还能更新，说明图中有负环，无法得出结果，否则完成。

完成上述循环之后能够满足对于所有的边都有 dist[b] ≤ dist[a] + w。

这里有一个问题需要声明：如果图中存在负权回路，则最短路不一定存在。而 Bellman-Ford算法可以判断出图中是否存在负权回路。因为上述伪代码中的迭代次数是有意义的，比如说我们当前迭代了 k 次，此时获得的 dist 数组是从源点出发，经过不超过 k 条边，走到每个点的最短距离。如果我们在进行第 n 次迭代的时候，dist 数组又发生了变化，则说明在这个最短路中，存在一条经过 n 条边的最短路，有 n 条边说明有 n + 1 个结点，但是我们一共只有 n 个点，因此由于抽屉原理，这 n + 1 个点中一定有两个结点完全一样，那么这个路径上一定存在负环。

因此，Bellman-Ford算法可以用来寻找负环，但是一般而言，寻找负环我们常常使用 spfa判断负环算法，我们后面会介绍。

但是有一类题目只能用Bellman-Ford算法来写，那就是经过最多 k 条边的最短路径问题，这种问题只能使用Bellman-Ford算法。

##### ACWING:853

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510, M = 10010;

int dist[N]; // 到源点的距离
int backup[N]; // 备份数组防止串联
int n, m, k;

// a 指向 b 权重为 w 的边
struct Edge {
    int a, b, w;
} edges[M];

void bellman_ford()
{
    // 初始化距离为无穷大
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0; // 源点到源点距离为 0

    for (int i = 0; i < k; i++)
    {
		// 备份上一次迭代的结果，防止出现串联（用本次更新的点去更新其他点）
	    memcpy(backup, dist, sizeof dist);
        for (int j = 0; j < m; j++) // 遍历所有边
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
			// 比较 1->b 和 1->a->b 的路径长度
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else cout << dist[n] << endl;
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 0; i < m; i++)
    {
        int a, b, w; 
        cin >> a >> b >> w;
        edges[i] = {a, b, w};
    }
    bellman_ford();
    return 0;
}
```



#### SPFA**（队列优化的Bellman-Ford算法）** 

> SPFA 的限制很小，只要图中没有负环，就可以用。 SPFA 不仅可以处理负权图，也可以处理正权图。

- SPFA 可以看作对 Bellman_ford 的优化：

  > 它优化的是这一步：d[b] = min(d[b], d[a] + w)
  > ​	只有当d[a]变小了，才会在下一轮循环中更新d[b]
  > ​	考虑用[BFS](https://so.csdn.net/so/search?q=BFS&spm=1001.2101.3001.7020)来做优化。用一个队列queue，来存放距离变小的节点。

- Bellman_ford 会遍历所有的边（固定 O(nm) ），很多边的遍历没有意义，只用遍历那些到源点距离边小的点所连接的边即可。

  >SPFA 和 Dijkstra 中的 st[] 数组：
  >​	Dijkstra 中的 st[] 中保存的是当前确定了到源点距离最短的点，确定以后不可逆。
  >​	SPFA 中的 st[] 仅仅表示当前发生过更新的点，是可逆的。
  >
  >SPFA 和 Dijksra 的思想：
  >​	Dijkstra 是基于贪心的思想，每次选择最近的点去更新其它点，过后就不再访问。
  >​	SPFA 中，只要有某个点的距离更新了，就加入到队列中，去更新其他点，所以每个点有可能重复入队。

**SPFA的好处**：能解决无负权边的问题，也能解决有负权边的问题，并且效率还比较高。但是当需要求在走不超过k条边的最短路问题上，就只能用Bellman-Ford算法了。

##### SPFA算法模板：

```cpp
时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n表示点数，m表示边数

int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

##### SPFA判断图中是否存在负环：

```cpp
时间复杂度是 O(nm), n表示点数，m表示边数

int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```

##### ACWING:851

```cpp

```

##### ACWING:852

```cpp
```











**Day32.(2023.3.11)**













## **待学习...**

## 数学知识

## 动态规划

## 贪心





























