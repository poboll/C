# 位运算与常用库函数

C++帮我们实现好了很多有用的函数，我们要避免重复造轮子。

## 一、位运算

​	`&` 与

​	`|` 或

​	`~` 非

​	`^` 异或

​	`>>` 右移

​	`<<` 左移

常用操作：

​	(1) 求x的第k位数字：`x >> k & 1`

​	(2) `lowbit(x) = x & -x`，返回x的最后一位1（a&~a+1）-a=~a+1

## 二、常用库函数

### 1. reverse翻转

`reverse `函数是O(n)的。

翻转一个`vector`：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
    vector<int> a({1, 2, 3, 4, 5});
    reverse(a.begin(), a.end());
    
    for(int x:a) cout << x <<' ';
    cout << endl;
    return 0;
}
```

翻转一个数组，元素存放在下标 `1 ~ n`：`reverse(a + 1, a + n + 1);`

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
    int a[] = {1, 2, 3, 4, 5};
    reverse(a, a+5);
    
    for(int x: a) cout << x << ' ';
    cout << endl;
    
    return 0;
}

```

### 2. unique去重

返回去重（只去掉**相邻**的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。

注意：
1、`unique`函数需要相同元素挨在一起，才能去重。该函数会把所有不同的元素放在开头。（如下图所示）
2、`unique`函数的返回值是不同元素的下一个位置（相当于新数组的`end`）

把一个vector去重：

```cpp
int m = unique(a.begin(), a.end()) – a.begin();
m表示数组中不同元素的数量

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{    
    vector<int> a({1, 1, 2, 2, 3, 4, 5});
    
    int m = unique(a.begin(), a.end()) - a.begin();

    cout << m << endl;
    
    for(int i = 0; i<m ; i++) cout << a[i] << ' ';
    cout << endl;
    
    return 0;
}
```

将`vector`数组不同元素之外的删除：

```cpp
a.erase(unique(a.begin(), a.end()), a.end());
```

把一个数组去重，元素存放在下标1~n：

```cpp
int m = unique(a + 1, a + n + 1) – (a + 1);


#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
    int a[] = {1, 1, 2, 2, 3, 4, 5};
    
    int m = unique(a, a+7) - a;

    cout << m << endl;
    
    for(int i = 0; i<m ; i++) cout << a[i] << ' ';
    cout << endl;
    
    return 0;
}
```

### 3. random shuffle 随机打乱

用法与`reverse`相同

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <ctime>

using namespace std;

int main()
{
    vector<int> a({1, 2, 3, 4, 5});
    
    srand(time(0)); // 随机种子
    
    random_shuffle(a.begin(), a.end());
    
    for(int x: a) cout << x << ' ';
    cout << endl;
    
    return 0;
}
```

### 4. sort

对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。

```C++
vector<int> a({1, 2, 3, 4, 5});
sort(a.begin(), a.end(), greater<int)());
```

```C++
int a[MAX _SIZE];
bool cmp(int a, int b) {return a > b; }
sort(a + 1, a + 1 + n, cmp);
```

把自定义的结构体 vector 排序，重载"小于号"运算符：

```C++
struct rec{ int id, x, y; }.
vector<rec> a;
bool operator <(const rec &a, const rec &b){.
	return ax< b.xll ax== b.x &&a.x<b.y;
}
sort(a.begin(). a.end());
```

```cpp
// 自行设定排序函数
// 如果a应该排在b前面，返回true；否则返回false
bool cmp(int a, int b)
{
	return a<b;
	// a<b那么a就应该排到b的前面。
	
	// return a > b;
	// 实现从大到小的排序
}
sort(a.begin(), a.end(), cmp);
```

把一个int数组（元素存放在下标 `1 ~ n` ）从大到小排序，传入比较函数：

```cpp
int a[MAX_SIZE];
bool cmp(int a, int b)
{
    return a > b;
}
sort(a + 1, a + n + 1, cmp);
```

把自定义的**结构体`vector`排序**，有两个方法：

1、重载**小于号**运算符：

```cpp
// 全局变量Rec 
struct Rec
{
    int id, x, y;
};

vector<Rec> a;

bool operator <(const Rec &a, const Rec &b)
{
        return a.x < b.x || a.x == b.x && a.y < b.y;
}

sort(a.begin(), a.end());
```

2、自定义比较函数

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
struct Rec
{
	int x, int y;
	bool operator< (const Rec &t)const
	{
		// 当前的x要不要排到t的前面
		// 如果小于t.x那么排到前面
		return x < t.x;
	}
}a[5];

bool cmp(Rec a, Rec b)
{
	return a.x < b.x;
}

int main()
{   
	for(int i=0, i<5; i++)
	{
		a[i].x = -i;
		a[i].y = i;
	}
	for(int i=0; i<5; i++) printf("(%d, %d)", a[i].x, a[i].y);
    cout << endl;
    
    sort(a, a+5, cmp);  // 从小到大
    
    for(int i=0; i<5; i++) printf("(%d, %d)", a[i].x, a[i].y);
    cout << endl;
    
    return 0;
}
```

### 5.lower bound/upper bound 二分

使用这两个函数首先需要数组或`vector`已经从小到大排好序。

`lower_bound`的第三个参数传入一个元素`x`，在两个迭代器（指针）指定的部分上执行二分查找，返回指向**第一个大于等于**`x`的元素的位置的迭代器（指针）。

`upper_bound`的用法和`lower_bound`大致相同，唯一的区别是查找**第一个大于**`x`的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。

在有序int数组（元素存放在下标`1 ~ n`）中查找大于等于x的最小整数的下标：

```cpp
int i = lower_bound(a + 1, a + 1 + n, x) - a; 
// 参数：begin/end/要比较的值
```

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
    int a[] = {1, 2, 4, 5, 6};
    
	int *p= lower_bound(a, a+5, 3);
	cout << *p << endl;
	// 如果参数是7（大于所有值），返回数组的end元素的随机值

	int t= lower_bound(a, a+5, 7) -a;
	// 返回下标5。
    
    return 0;
}
```

在有序`vector<int>`中查找小于等于x的最大整数（假设一定存在）：

```cpp
int y = *--upper_bound(a.begin(), a.end(), x);
```

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
    vector<int> a{1, 2, 4, 5, 6};

	int t = lower_bound(a.begin(), a.end(), 3) - a.begin();
	cout << a[t] << endl; 
    
    return 0;
}
```