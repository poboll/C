/*845.八数码
在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3 的网格中。
例如：
1 2 3
x 4 6
7 5 8
在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。
我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：
1 2 3
4 5 6
7 8 x
例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。
交换过程如下：
1 2 3 | 1 2 3 | 1 2 3 | 1 2 3 |
x 4 6 | 4 x 6 | 4 5 6 | 4 5 6 |
7 5 8 | 7 5 8 | 7 x 8 | 7 8 x |
现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。
输入格式
输入占一行，将 3×3 的初始网格描绘出来。
例如，如果初始网格如下所示：
1 2 3
x 4 6
7 5 8
则输入为：1 2 3 x 4 6 7 5 8
输出格式
输出占一行，包含一个整数，表示最少交换次数。
如果不存在解决方案，则输出 −1。
输入样例：
2 3 4 1 5 x 7 6 8
输出样例
19
*/
/*本题的本质即为求图中某个点到达其右下角的点的最短路，且图中每条路的权重相同，因此我们可以用bfs来求解这道题。首先，我们需要定义队列q用来完成bfs的核心操作，定义unordered_map<string, int> d 哈希表用来储存初始状态到每个状态的距离(状态就是x在图中的位置)，且由于二维数组表示x位置不方便映射，所以我们将二维坐标转化为一维坐标，即在输入的时候将其输入到一个string state中，表明初始状态。而且还需要定义方向数组dx[4], dy[4]用于广搜中对当前状态中x的位置进行4个方向的移动。

那么bfs函数具体应如何实现? 开始时，将传入的表明初始状态字符串state入队，同时赋值哈希表d[state] = 0,表示初始状态距离自己为0。在bfs的while(q.size())循环中，每一次循环取出队头元素，并以此为搜索起点对其左、上、右和下符合条件的点进行搜索处理。但要继续向下处理每一种状态，因为原串只能表示一个状态，所以我们要对原串state进行改变，并储存到队列中，这步移动操作我们通过swap来完成，但要想将x移到下一个位置，首先要找到x在一维维坐标下的位置，然后转化成二维坐标，可以这样int k = t.find(‘x’)//t表示队头元素，int x = k / 3，int y = k % 3，x和y就是’x’在二维坐标系下的横纵坐标(可自己画图论证)。然后将(x, y)在for循环中向4个方向进行移动并用变量a，b记录移动之后的值，即a = x + dx[i] ,b = y + dy[i]，如果移动之后的位置没有越界，则交换两个中’x‘的位置，即swap(t[3 * a + b], t[k]),如果交换之后的状态没有被搜索过(d.count(t)为空)，则更新d数组，在原来的基础上加1，并将新状态入队。完成之后，要恢复到原来状态，再对原点进行拓展。如此反复，直至队列为空或到达最终状态，如到达最终状态返回d的值表示最短路，队列为空的情况则表示无法到达，返回-1。*/
#include<iostream>
#include<cstdio>
#include<unordered_map>
#include<queue>
using namespace std;
int bfs(string state) {
	queue<string> q;
	unordered_map<string, int> d;//哈希表 记录每种状态距离初始状态的距离 
	q.push(state); 
	d[state] = 0;//初始状态距离为0 
	int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
	string end = "12345678x";//end表示最终状态 
	while (q.size()) {
		auto t = q.front();//取出队头元素 
		q.pop();
		if (t == end) return d[t];//如果搜索到end就返回移动的距离 
		int distance = d[t];
		int k = t.find('x');//查找到x的一维下标 
		int x = k / 3, y = k % 3;//将一维坐标转化为二维坐标 
		for (int i = 0; i < 4; i ++ ) {
			int a = x + dx[i], b = y + dy[i];
			if (a >= 0 && a < 3 && b >= 0 && b < 3) {
				swap(t[a * 3 + b], t[k]);
				if (!d.count(t)) {
					d[t] = distance + 1;
					q.push(t); 
				}
				swap(t[a * 3 + b], t[k]);//状态恢复 
			}
		}
	}
	return -1;
}
int main() {
	char s;
	string state;
	for (int i = 0; i < 9; i ++ )  {
	    cin >> s;
		state += s;	
	}
	cout << bfs(state) << endl;//state为初始状态， 即以一维字符串的形式储存二维矩阵 
	return 0;
}
