/*95.费解的开关
你玩过“拉灯”游戏吗？
25 盏灯排成一个 5×5 的方形。
每一个灯都有一个开关，游戏者可以改变它的状态。
每一步，游戏者可以改变某一个灯的状态。
游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。
我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。
下面这种状态
10111
01101
10111
10000
11011
在改变了最左上角的灯的状态后将变成：
01111
11101
10111
10000
11011
再改变它正中间的灯后状态将变成：
01111
11001
11001
10100
11011
给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。
输入格式
第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。
以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。
每组数据描述了一个游戏的初始状态。
各组数据间用一个空行分隔。
输出格式
一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。
对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。
数据范围
0<n≤500
输入样例
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
输出样例
3
2
-1
*/
/*思路
由观察可得i行j列的灯如果是暗的，为了不影响i-1行已经完成的全亮灯的状态，
只好通过按下i+1行j列的按钮来改变i行j列的灯的状态；
由此可得每一行某一列的灯的状态只能通过同列下一行的按钮改变
特殊地，第0行的灯不管是亮灭，都可以任意按下它们的按钮
而对于第0行的5个按钮各个都可以选择按或不按，一共有25=32种状态，在代码中用op表示，
如01001表示按下第0行的第2个按钮和第5个按钮，
再比如11111表示第0行的所有按钮都被按一次，
（通过i >> k & 1 操作来判断某位是否为1即是否被按下）
于是res最小值便在这32种操作后成功完成目标的结果中产生。*/