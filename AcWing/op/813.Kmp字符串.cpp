/*831.Kmp字符串
给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模板串P在模式串S中多次作为子串出现。
求出模板串P在模式串S中所有出现的位置的起始下标。
输入格式
第一行输入整数N，表示字符串P的长度。
第二行输入字符串P。
第三行输入整数M，表示字符串S的长度。
第四行输入字符串M。
输出格式:共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。
数据范围:1≤N≤10^4    1≤M≤10^5
输入样例：
3
aba
5
ababa
输出样例：
0 2*/
#include <iostream>
using namespace std;
const int N = 10010, M = 100010;
int n, m;
int ne[N];
char s[M], p[N];
int main() {
    cin >> n >> p+1 >> m >> s+1;        	//下标从1开始
    for(int i = 2, j = 0; i <= n; i++) { 	//i = 1时next数组为0
        while(j && p[i] != p[j+1]) j = ne[j];
        if(p[i] == p[j+1]) j++;
        ne[i] = j;    
    }
    for(int i = 1, j = 0; i <= m; i++) {
        while(j && s[i] != p[j+1]) j = ne[j];
        //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
        if(s[i] == p[j+1]) j++;//当前元素匹配，j移向p串下一位
        if(j == n) {			//匹配成功，进行相关操作
            cout << i-n << ' ';
            j = ne[j];      //找到完全匹配的字符串后重新从p的ne[n]位置开始搜索
        }
    }
}
