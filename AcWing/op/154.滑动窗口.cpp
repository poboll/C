/*154.滑动窗口
给定一个大小为 n≤10^6的数组。
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 [1 3 -1 -3 5 3 6 7]，k
为 3 。
窗口位置	最小值	最大值
[1 3 -1] -3 5 3 6 7	-1	3
1 [3 -1 -3] 5 3 6 7	-3	3
1 3 [-1 -3 5] 3 6 7	-3	5
1 3 -1 [-3 5 3] 6 7	-3	5
1 3 -1 -3 [5 3 6] 7	3	6
1 3 -1 -3 5 [3 6 7]	3	7
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
输入格式
输入包含两行。
第一行包含两个整数 n
和 k ，分别代表数组长度和滑动窗口的长度。
第二行有 n 个整数，代表数组的具体数值。
同行数据之间用空格隔开。
输出格式
输出包含两个。
第一行输出，从左至右，每个位置滑动窗口中的最小值。
第二行输出，从左至右，每个位置滑动窗口中的最大值。
输入样例
8 3
1 3 -1 -3 5 3 6 7
输出样例
-1 -3 -3 -3 3 3
3 3 5 5 6 7
*/
/*题目思路
用单调队列的思想，如输出最小值时，
入队前将比当前数字大的从队尾出队，输出结果时输出队头，维护一个长度1<=队列长度<=滑动窗口的队列。*/
#include <iostream>//三步
using namespace std;
const int N = 1e6 + 10;
int hh = 0, tt = -1, n, k, a[N], q[N];//a数组存数字,q数组是单调队列存下标
int main() {
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n; i++)
        scanf("%d",&a[i]);//先存完再进行滑动窗口操作
    for(int i = 0; i < n; i ++ ) {
    //判断队列非空  hh <= tt
    //1.队首是否滑出滑动窗口
    //滑动窗口下标大于队首下标则说明队首滑出滑动窗口，需剔除队首
        if(hh <= tt && i - k + 1 > q[hh])  hh++;
    //先求最小值
    //2.为了保持单调队列的单调性，需在队尾进行删除操作。如：数组为 3 5 ,新进入的滑动窗口
    //数字为4，若在队首进行删除，那么3<4,那么就不用进行删除操作。数组就为3 5 4
    //不满足单调情况。而在队尾进行删除操作，因为5>4，3<4，所以5被删除，留下数组3 4
    //具有单调性
        while(hh <= tt && a[i] <= a[q[tt]])  tt--;
        q[ ++ tt] = i;//一定要在前两步操作后与下一步操作前存入
    //3.必须在滑动窗口有三个元素时输出。若滑动窗口内只有两个元素，则不输出
        if(i >= k - 1)    printf("%d ", a[q[hh]]);//对头为最小元素
    }
    puts("");//换行符
    //求最大值同理
    hh = 0, tt = -1;//hh tt值在求最小值时改变了，需得重新初始化
     for(int i = 0; i < n; i ++) {
        if(hh <= tt && i - k + 1 > q[hh])  hh ++;
        while(hh <= tt && a[i] >= a[q[tt]])  tt --;
        q[ ++ tt] = i;
        if(i >= k - 1)      printf("%d ", a[q[hh]]);
    }
    return 0;
}