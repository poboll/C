/*841.字符串哈希
给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1，r1，l2，r2，请你判断 [l1，r1] 和 [l2，r2] 这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。
输入格式
第一行包含整数 n 和 m，表示字符串长度和询问次数。
第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。
接下来 m 行，每行包含四个整数 l1，r1，l2，r2，表示一次询问所涉及的两个区间。
注意，字符串的位置从 1 开始编号。
输出格式
对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。
每个结果占一行。
数据范围
1 ≤ n，m ≤ 10 ^ 5
输入样例：
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
输出样例：
Yes
No
Yes
*/
/*思路分析：
字符串哈希算法用来快速判断两段字符串是否相同，我们实际上是将字符串看成是一个P进制的数，其中P一般为131或13331这样产生冲突的概率会很小，可以理解为几乎没有冲突；一开始的时候使用O(n)的时间预处理一个字符串所有前缀的哈希值，然后我们就可以使用O(1)的时间查询出字符串的哈希值，这样就可以快速判断两个字符串是否相等，字符串哈希一般涉及到下图中的公式，包括计算一个字符串的哈希值，计算字符串中子串的哈希值等。下图是计算一个字符串的P进制数字的相关计算公式：
*/
#include <iostream>
using namespace std;
const int N = 1e5 + 10,P = 131;
//因为ASCII码范围为 0~127，共 128个，按照经验来说，一般取 131（128 + 3）或13331，这样产生冲突的概率低
typedef unsigned long long ULL;
//选用ULL第一点是因为P一旦次方数高了以后会出现很范围大的数
//第二点unsigned long long的范围是[0,2^64 - 1],所以超范围之后会自动进行%2^64操作
int n,m;
char str[N];
ULL h[N],p[N];
//首先是str看成是一个p进制的数，每位字符用ASCII码替代
//利用前缀哈希求出子串哈希 e.g. hash(def) = hash(abcdef) - hash(abc) * P ^ 3
ULL get(int l,int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
    //写成平常公式就是 h[r] - h[l - 1] * P^(r-l+1)
}
int main()
{
    scanf("%d%d%s", &n, &m, str + 1);
    p[0] = 1;
    for(int i = 1; i <= n; i ++) {
        h[i] = h[i - 1] * P + str[i];//左移一位然后加上新的字母的ASCII
        p[i] = p[i - 1] * P;//提高次幂
    }
    while(m -- ) {
        int l1, l2, r1, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);//cin >> l1 >> r1 >> l2 >> r2;
        if(get(l1,r1) == get(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}